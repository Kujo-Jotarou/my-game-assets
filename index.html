<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Raiders</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Press Start 2P', 'Courier New', Courier, monospace;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        h1 {
            font-size: 24px;
            color: #fca311;
            margin: 10px 0;
            text-shadow: 2px 2px #000;
            flex-shrink: 0;
        }
        #game-wrapper {
            width: 100%;
            max-width: 600px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 0;
            padding: 10px;
            box-sizing: border-box;
        }
        #uiContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 5px 0;
            font-size: 14px;
            flex-shrink: 0;
            box-sizing: border-box; 
        }
        #gameContainer {
            position: relative;
            width: 100%;
            flex-grow: 1;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0f0f1b;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(252, 163, 17, 0.5);
            touch-action: none;
        }
        #lives {
            color: #ff4d6d;
            font-weight: bold;
        }
        #muteButton {
            background: #33415c;
            border: 2px solid #4a5568;
            color: #e0e0e0;
            padding: 5px 10px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 46, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s 0.3s, opacity 0.3s linear;
            z-index: 10;
            border-radius: 10px;
        }
        .screen.active {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s linear;
        }
        .screen h2 { font-size: 40px; margin-bottom: 20px; color: #fca311; }
        .screen p { font-size: 20px; margin: 10px 0; }
        .screen button { background-color: #fca311; color: #1a1a2e; border: none; padding: 15px 30px; font-size: 20px; font-family: inherit; border-radius: 8px; cursor: pointer; text-transform: uppercase; transition: all 0.2s; box-shadow: 0 4px 0 #c87e07; margin-top: 20px; }
        .screen button:hover { transform: translateY(-2px); box-shadow: 0 6px 0 #c87e07; }
        .screen button:active { transform: translateY(2px); box-shadow: 0 2px 0 #c87e07; }
        .share-buttons { 
            margin-top: 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 260px;
        }
        .share-buttons-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }
        .share-buttons a {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 5px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: transform 0.2s;
            text-align: center;
            flex: 1;
        }
        .share-x { background-color: #000000; }
        .share-facebook { background-color: #1877F2; }
        .share-line { background-color: #00B900; }
        .share-tiktok { background-color: #000000; }
        .share-instagram { background: #d6249f; background: radial-gradient(circle at 30% 107%, #fdf497 0%, #fdf497 5%, #fd5949 45%,#d6249f 60%,#285AEB 90%); }


        #adContainer a { display: block; margin-bottom: 15px;}
        #sound-toggle-container { margin-top: 25px; }
        #sound-toggle { display: flex; align-items: center; justify-content: center; font-size: 14px; }
        #sound-toggle label { margin-right: 10px; }
        
        /* --- 広告サイズ修正 --- */
        #bottom-banner-ad {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0,0,0,0.8);
            padding: 0;
            box-sizing: border-box;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-shrink: 0;
            height: 40px; /* 高さを45pxから40pxに修正 */
            overflow: hidden;
        }
        #banner-content {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        #banner-content img {
            max-height: 100%;
            width: auto;
        }
        #close-banner-btn {
            font-size: 10px;
            padding: 5px 8px;
            margin-left: 15px;
            background: #ff4d6d;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>Block Raiders</h1>
        <div id="game-wrapper">
            <div id="uiContainer">
                <div>
                    <span id="score">SCORE: 0</span><br>
                    <span id="level">LEVEL: 1</span>
                </div>
                <div id="lives">LIVES: 3</div>
                <button id="muteButton">SOUND: ON</button>
            </div>
            <div id="gameContainer">
                <canvas id="gameCanvas"></canvas>
                <div id="combo-display" style="position: absolute; color: #ff4500; font-size: 20px; opacity: 0; transition: opacity 0.5s, transform 0.5s; text-shadow: 1px 1px 3px #000;"></div>
                <div id="startScreen" class="screen active">
                    <h2>Block Raiders</h2>
                    <p>High Score: <span id="startHighScore">0</span></p>
                    <button id="startButton" disabled>LOADING...</button>
                    <div id="sound-toggle-container">
                        <div id="sound-toggle">
                             <label for="sound-checkbox">SOUND</label>
                            <input type="checkbox" id="sound-checkbox" checked>
                        </div>
                    </div>
                </div>
                <div id="gameOverScreen" class="screen">
                    <h2 id="gameOverTitle">GAME OVER</h2>
                    <p>LEVEL: <span id="resultLevel">1</span></p>
                    <p>SCORE: <span id="resultScore">0</span></p>
                    <p>HIGH SCORE: <span id="resultHighScore">0</span></p>
                    <button id="restartButton">もう一度プレイ</button>
                    <div class="share-buttons">
                        <div class="share-buttons-row">
                            <a id="shareX" class="share-x" href="#" target="_blank">X</a>
                            <a id="shareFacebook" class="share-facebook" href="#" target="_blank">Facebook</a>
                            <a id="shareLine" class="share-line" href="#" target="_blank">LINE</a>
                        </div>
                        <div class="share-buttons-row">
                             <a id="shareTikTok" class="share-tiktok" href="https://www.tiktok.com/" target="_blank">TikTok</a>
                            <a id="shareInstagram" class="share-instagram" href="https://www.instagram.com/" target="_blank">Instagram</a>
                        </div>
                    </div>
                </div>
                 <div id="adScreen" class="screen">
                    <div id="adContainer">
                       </div>
                    <p><span id="adTimer"></span></p>
                    <button id="adRestartButton" style="display:none;">もう一度プレイ</button>
                     <div class="share-buttons">
                         <p style="font-size: 14px; margin-bottom: 10px; grid-column: 1 / -1; width: 100%; text-align: center;">シェアで今後表示しない</p>
                        <div class="share-buttons-row">
                            <a id="shareXAd" class="share-x" href="#" target="_blank">X</a>
                            <a id="shareFacebookAd" class="share-facebook" href="#" target="_blank">Facebook</a>
                            <a id="shareLineAd" class="share-line" href="#" target="_blank">LINE</a>
                        </div>
                        <div class="share-buttons-row">
                             <a id="shareTikTokAd" class="share-tiktok" href="https://www.tiktok.com/" target="_blank">TikTok</a>
                            <a id="shareInstagramAd" class="share-instagram" href="https://www.instagram.com/" target="_blank">Instagram</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="bottom-banner-ad">
            <span id="banner-content"></span>
            <button id="close-banner-btn">×</button>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        let ctx; 
        const gameContainer = document.getElementById('gameContainer');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const muteButton = document.getElementById('muteButton');
        const soundCheckbox = document.getElementById('sound-checkbox');
        const adScreen = document.getElementById('adScreen');
        const adTimerEl = document.getElementById('adTimer');
        const adRestartButton = document.getElementById('adRestartButton');
        const bottomBannerAd = document.getElementById('bottom-banner-ad');
        const adContainer = document.getElementById('adContainer');
        const bannerContent = document.getElementById('banner-content');
        const closeBannerBtn = document.getElementById('close-banner-btn');
        
        const LOGICAL_WIDTH = 480;
        const LOGICAL_HEIGHT = 600;

        const PADDLE_WIDTH_RATIO = 0.2; 
        const PADDLE_HEIGHT_RATIO = 0.04;
        const BALL_RADIUS_RATIO = 0.01;
        const LASER_WIDTH_RATIO = 0.01;
        const LASER_HEIGHT_RATIO = 0.025;
        const ITEM_SIZE_RATIO = 0.025;
        
        let PADDLE_WIDTH, PADDLE_HEIGHT, BALL_RADIUS, LASER_WIDTH, LASER_HEIGHT, ITEM_SIZE, PADDLE_Y;

        const INVADER_ROWS = 5, INVADER_COLS = 8;
        let INVADER_WIDTH, INVADER_HEIGHT, INVADER_PADDING, INVADER_OFFSET_TOP, INVADER_OFFSET_LEFT;

        const INVADER_HITBOX_INSET_X_RATIO = 0.11;
        const INVADER_HITBOX_INSET_Y_RATIO = 0.08;
        const PLAYER_HITBOX_INSET_X_RATIO = 0.18;
        const PLAYER_HITBOX_INSET_Y_RATIO = 0.18;

        const BASE_SPEED = 0.02268;
        let ballSpeed, laserSpeed, itemSpeed;

        const ITEM_DROP_CHANCE = 0.09; 
        const MULTIBALL_CHANCE = 0.5;
        const PIERCE_DURATION = 8000;
        const SHIELD_EXPAND_DURATION = 10000;
        const INVINCIBLE_DURATION = 8000;
        const GAME_URL = "https://kujo-jotarou.github.io/my-game-assets/";
        const BGM_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/bgm.MP3";
        const BUTTON_CLICK_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E3%83%9C%E3%82%BF%E3%83%B3.mp3";
        const ENEMY_DEATH_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E6%95%B5%E6%AD%BB%E4%BA%A1.mp3";
        const ENEMY_HIT_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E6%95%B5%E8%A2%AB%E5%BC%BE.mp3";
        const PLAYER_HIT_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E8%A2%AB%E5%BC%BE.mp3";
        const HEAL_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E5%9B%9E%E5%BE%A9.mp3";
        const POWERUP_URL = "https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E3%83%91%E3%83%AF%E3%83%BC%E3%82%A2%E3%83%83%E3%83%97.mp3";

        let player, balls, invaders, lasers, items, particles, stars;
        let score, lives, level, highScore = 0;
        let rightPressed = false, leftPressed = false;
        let gameStarted = false, gameOver = false, isLevelTransitioning = false;
        let invadersMoveDirection, invaderRowDirections, invadersMoveDown, invaderSpeed, frameCount;
        let pierceTimeoutId = null;
        let shieldTimeoutId = null;
        let invincibleTimeoutId = null;
        let touchStartX = null;
        let hasSharedEver = localStorage.getItem('blockRaidersShared') === 'true';
        let adTimerInterval = null;
        let audioInitialized = false;
        let gameOverCount = 0;
        let animationFrameId;
        
        let comboCount = 0;
        let scoreMultiplier = 1;
        let comboMultiplierDisplayTimeout;
        let comboMultiplierDisplay;

        let db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const sfxBus = new Tone.Channel().toDestination();
        const melodySynth = new Tone.Synth({volume: -4}).connect(sfxBus);

        let hitBuffer, destroyBuffer, playerHitBuffer, itemBuffer, healBuffer, buttonClickBuffer;

        function playSound(buffer) {
            if (!audioInitialized || Tone.Master.mute || !buffer) return;
            const player = new Tone.Player().toDestination();
            player.buffer = buffer;
            player.connect(sfxBus);
            player.start();
            setTimeout(() => {
                if(player && !player.disposed){
                    player.dispose();
                }
            }, buffer.duration * 1000 + 100); 
        }

        const sounds = {
            hit: () => playSound(hitBuffer),
            destroy: () => playSound(destroyBuffer),
            laser: () => {
                if (!audioInitialized || Tone.Master.mute) return;
                const laserSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 } }).connect(sfxBus);
                laserSynth.volume.value = -18;
                const now = Tone.now();
                laserSynth.triggerAttack(now);
                laserSynth.frequency.setValueAtTime("A5", now);
                laserSynth.frequency.rampTo("A4", now + 0.2);
                laserSynth.triggerRelease(now + 0.2);
                setTimeout(() => laserSynth.dispose(), 300);
            },
            playerHit: () => playSound(playerHitBuffer),
            getItem: () => playSound(itemBuffer),
            getLife: () => playSound(healBuffer),
            getMultiBall: () => playSound(itemBuffer),
            getPierce: () => playSound(itemBuffer),
            getShield: () => playSound(itemBuffer),
            getInvincible: () => playSound(itemBuffer),
            buttonClick: () => playSound(buttonClickBuffer),
            gameOver: () => { const now = Tone.now(); melodySynth.triggerAttackRelease('G3', '8n', now); melodySynth.triggerAttackRelease('F#3', '8n', now + 0.1); melodySynth.triggerAttackRelease('F3', '8n', now + 0.2); melodySynth.triggerAttackRelease('E3', '4n', now + 0.3); },
            win: () => { const now = Tone.now(); melodySynth.triggerAttackRelease('C5', '8n', now); melodySynth.triggerAttackRelease('E5', '8n', now + 0.1); melodySynth.triggerAttackRelease('G5', '8n', now + 0.2); melodySynth.triggerAttackRelease('C6', '4n', now + 0.3); }
        };

        const bgmPlayer = new Tone.Player({
            loop: true,
            volume: -12,
        }).toDestination();
        
        function startBGM() { if (bgmPlayer.loaded && bgmPlayer.state !== 'started' && !Tone.Master.mute) { bgmPlayer.start(); } }
        function stopBGM() { if(bgmPlayer.state === 'started') { bgmPlayer.stop(); } }

        async function initializeFirebase() {
             try {
                if (typeof firebase === 'undefined' || typeof __firebase_config === 'undefined') {
                    throw new Error("Firebase config not available");
                }
                const firebaseConfig = JSON.parse(__firebase_config);
                 if (!firebaseConfig.projectId) throw new Error("Firebase projectId is missing in config");
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
                
                const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if(token) {
                    await auth.signInWithCustomToken(token);
                } else {
                    await auth.signInAnonymously();
                }
                userId = auth.currentUser.uid;
                await loadHighScore();

            } catch (e) { 
                console.warn("Firebase init failed, falling back to local storage:", e.message); 
                userId = `local-${crypto.randomUUID()}`;
                loadHighScore();
            }
        }
        async function loadHighScore() {
            if (!userId) return;
            if (db) {
                try {
                    const docRef = db.collection(`artifacts/${appId}/users/${userId}/highscores`).doc("gameData");
                    const docSnap = await docRef.get();
                    if (docSnap.exists) { highScore = docSnap.data().score || 0; }
                } catch (e) {
                    console.warn("Firestore load failed, using local storage:", e);
                    highScore = parseInt(localStorage.getItem('blockRaidersHighScore') || '0', 10);
                }
            } else {
                highScore = parseInt(localStorage.getItem('blockRaidersHighScore') || '0', 10);
            }
            document.getElementById('startHighScore').textContent = highScore;
            document.getElementById('resultHighScore').textContent = highScore;
        }
        async function saveHighScore(newScore) {
            if (!userId) return;
            if (db) {
                try {
                    await db.collection(`artifacts/${appId}/users/${userId}/highscores`).doc("gameData").set({ score: newScore });
                } catch (e) {
                    console.warn("Firestore save failed, using local storage:", e);
                    localStorage.setItem('blockRaidersHighScore', newScore);
                }
            } else {
                 localStorage.setItem('blockRaidersHighScore', newScore);
            }
        }
        
        // --- 機体デザイン修正 ---
        function drawPlayerShape(x, y, width, height) {
            const w = width / 10;
            const h = height / 8; // 機体の縦の分割数を変更

            // 新しい機体デザイン
            ctx.fillStyle = "#E5E4E2"; // 本体色
            const body = [
                [0,0,0,0,1,1,0,0,0,0], 
                [0,0,0,1,1,1,1,0,0,0], 
                [0,0,1,1,1,1,1,1,0,0], 
                [0,1,1,1,1,1,1,1,1,0], 
                [1,1,0,1,1,1,1,0,1,1],
                [1,0,0,0,0,0,0,0,0,1]
            ];
            for (let row = 0; row < body.length; row++) {
                for (let col = 0; col < body[row].length; col++) {
                    if (body[row][col]) {
                        ctx.fillRect(x + col * w, y + row * h, w, h);
                    }
                }
            }

            // コックピット
            ctx.fillStyle = '#7DF9FF'; // 水色
            ctx.fillRect(x + 4 * w, y + 2 * h, w * 2, h);

            // --- ジェット炎のアニメーション修正 ---
            const flameColors = ['#FF4500', '#FFD700', '#FFA500']; // 炎の色を複数用意
            const flameIndex = Math.floor(Date.now() / 100) % flameColors.length; // 時間で色を切り替え
            ctx.fillStyle = flameColors[flameIndex];

            // 炎の形を少しランダムにする
            const flameHeight = h * (1.5 + Math.random() * 0.5);
            ctx.fillRect(x + 3 * w, y + 6 * h, w, flameHeight);
            ctx.fillRect(x + 6 * w, y + 6 * h, w, flameHeight);
        }

        
        function drawPlayer() {
            ctx.save();
            if(player.isInvincible) {
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 80) * 0.2;
                ctx.shadowColor = `hsl(${Date.now() / 20 % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
            }
            drawPlayerShape(player.x, player.y, player.width, player.height);
            ctx.restore();
            const barrierWidth = player.shieldWidth;
            const barrierX = player.x - (barrierWidth - player.width) / 2;
            const barrierY = player.y - player.height * 0.2;
            ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.3;
            let grad, shadowColor;
            if (player.shieldEnhanced) {
                grad = ctx.createLinearGradient(barrierX, barrierY, barrierX + barrierWidth, barrierY);
                grad.addColorStop(0, "rgba(255, 0, 0, 0)");
                grad.addColorStop(0.2, "rgba(255, 69, 0, 0.8)");
                grad.addColorStop(0.8, "rgba(255, 69, 0, 0.8)");
                grad.addColorStop(1, "rgba(255, 0, 0, 0)");
                shadowColor = '#ff4500';
            } else {
                grad = ctx.createLinearGradient(barrierX, barrierY, barrierX + barrierWidth, barrierY);
                grad.addColorStop(0, "rgba(0, 225, 255, 0)");
                grad.addColorStop(0.2, "rgba(173, 216, 230, 0.8)");
                grad.addColorStop(0.8, "rgba(173, 216, 230, 0.8)");
                grad.addColorStop(1, "rgba(0, 225, 255, 0)");
                shadowColor = '#00e1ff';
            }
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 15;
            ctx.fillStyle = grad;
            ctx.fillRect(barrierX, barrierY, barrierWidth, 6);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1.0;
        }

        function drawBall(ball) {
            ctx.beginPath();
            if (ball.isPiercing) {
                const grad = ctx.createRadialGradient(ball.x, ball.y, ball.radius * 0.2, ball.x, ball.y, ball.radius);
                grad.addColorStop(0, '#FFFFFF');
                grad.addColorStop(0.7, '#C9A0DC');
                grad.addColorStop(1, '#9400D3');
                ctx.fillStyle = grad;
                ctx.shadowColor = '#C9A0DC';
                ctx.shadowBlur = 20;
            } else {
                ctx.fillStyle = "#fff";
                ctx.shadowBlur = 0;
            }
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            if (ball.isPiercing) {
                 for(let i=0; i<3; i++){
                    ctx.beginPath();
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * ball.radius + ball.radius;
                    const particleX = ball.x + Math.cos(angle) * dist;
                    const particleY = ball.y + Math.sin(angle) * dist;
                    ctx.arc(particleX, particleY, Math.random() * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(201, 160, 220, ${Math.random() * 0.6})`;
                    ctx.fill();
                }
            }
            ctx.closePath();
        }
        function drawBalls() { balls.forEach(drawBall); }
        function drawLasers() { lasers.forEach(l => { ctx.fillStyle = '#ff4d6d'; ctx.fillRect(l.x, l.y, LASER_WIDTH, LASER_HEIGHT); }); }
        function drawHeart(x, y, size) {
            ctx.fillStyle = '#ff4d6d'; ctx.beginPath(); ctx.moveTo(x, y + size / 4);
            ctx.quadraticCurveTo(x, y, x + size / 4, y); ctx.quadraticCurveTo(x + size / 2, y, x + size / 2, y + size / 4);
            ctx.quadraticCurveTo(x + size / 2, y, x + size * 3 / 4, y); ctx.quadraticCurveTo(x + size, y, x + size, y + size / 4);
            ctx.quadraticCurveTo(x + size, y + size / 2, x + size * 3 / 4, y + size * 3 / 4);
            ctx.lineTo(x + size / 2, y + size); ctx.lineTo(x + size / 4, y + size * 3 / 4);
            ctx.quadraticCurveTo(x, y + size / 2, x, y + size / 4); ctx.fill();
        }
        function drawItems() {
            items.forEach(item => {
                ctx.font = `${ITEM_SIZE * 0.9}px 'Press Start 2P'`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (item.type === 'life') { drawHeart(item.x, item.y, ITEM_SIZE); } 
                else if (item.type === 'multiBall') {
                    ctx.fillStyle = '#fceb00'; ctx.beginPath(); ctx.arc(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2, ITEM_SIZE / 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.fillText('B', item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2 + 1);
                } else if (item.type === 'pierce') {
                    ctx.fillStyle = '#9400d3';
                    ctx.beginPath(); ctx.arc(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2, ITEM_SIZE / 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.fillText('P', item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2 + 1);
                } else if (item.type === 'wideShield') {
                    ctx.fillStyle = '#32cd32';
                    ctx.beginPath(); ctx.arc(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2, ITEM_SIZE / 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.fillText('W', item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2 + 1);
                } else if (item.type === 'invincible') {
                    ctx.fillStyle = '#FFD700';
                    ctx.save();
                    ctx.translate(item.x + ITEM_SIZE/2, item.y + ITEM_SIZE/2);
                    ctx.beginPath();
                    for(let i=0; i<10; i++){
                        const angle = i * Math.PI / 5;
                        const r = i % 2 === 0 ? ITEM_SIZE * 0.5 : ITEM_SIZE * 0.25;
                        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            });
        }
        
        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    alpha: 1,
                    color: color,
                    lifespan: Math.random() * 30 + 30
                });
            }
        }

        function drawCracks(x, y, width, height, damage) {
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            for(let i=0; i < damage; i++) {
                ctx.beginPath();
                ctx.moveTo(x + Math.random() * width, y + Math.random() * height);
                ctx.lineTo(x + Math.random() * width, y + Math.random() * height);
                ctx.stroke();
            }
        }
        
        function drawInvaderShape(x, y, width, height, color, damage, maxHealth) {
            ctx.fillStyle = color; 
            const w = width / 10; 
            const h = height / 8;
            const pattern = [ [0,0,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0],[1,1,1,0,1,1,0,1,1,1],[1,1,1,1,1,1,1,1,1,1],[0,0,1,0,0,0,0,1,0,0],[0,1,0,1,0,0,1,0,1,0],];
            for (let row = 0; row < pattern.length; row++) { for (let col = 0; col < pattern[row].length; col++) { if (pattern[row][col]) { ctx.fillRect(x + col * w, y + row * h, w, h); } } }
            
            if(damage > 0) {
                drawCracks(x, y, width, height, damage);
            }
        }

        function drawInvaders() { 
            invaders.forEach(c => c.forEach(i => { 
                if (i.status > 0) { 
                    drawInvaderShape(i.x, i.y, INVADER_WIDTH, INVADER_HEIGHT, i.color, i.maxHealth - i.status, i.maxHealth); 
                } 
            })); 
        }
        function drawStars() {
            if (!stars) {
                stars = [];
                for (let i = 0; i < 150; i++) {
                    stars.push({
                        x: Math.random() * LOGICAL_WIDTH,
                        y: Math.random() * LOGICAL_HEIGHT,
                        radius: Math.random() * 1.5,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
            }
            
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > LOGICAL_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * LOGICAL_WIDTH;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawParticles() {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                ctx.beginPath();
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.alpha;
                ctx.fillRect(p.x, p.y, 3, 3);
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.03;
                p.lifespan--;
                if(p.lifespan <= 0) {
                    particles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1.0;
        }
        
        function drawScoreMultiplier() {
            const display = document.getElementById('combo-display');
            if (comboMultiplierDisplay && comboMultiplierDisplay.alpha > 0) {
                const rect = canvas.getBoundingClientRect();
                const scale = rect.width / LOGICAL_WIDTH;

                display.innerText = comboMultiplierDisplay.text;
                display.style.left = `${(comboMultiplierDisplay.x / LOGICAL_WIDTH * 100)}%`;
                display.style.top = `${(comboMultiplierDisplay.y / LOGICAL_HEIGHT * 100)}%`;
                display.style.fontSize = `${18 * scale}px`;
                display.style.opacity = comboMultiplierDisplay.alpha;
                display.style.transform = `translate(-50%, -50%) scale(${1 + (1-comboMultiplierDisplay.alpha)})`;
            } else if(display) {
                display.style.opacity = 0;
            }
        }


        function triggerScreenEffect() {
            gameContainer.classList.add('shake');
            const flash = document.createElement('div');
            Object.assign(flash.style, { position: 'absolute', top: '0', left: '0', width: '100%', height: '100%', backgroundColor: 'rgba(255, 0, 0, 0.4)', opacity: '1', transition: 'opacity 0.3s ease-out', zIndex: '5' });
            gameContainer.appendChild(flash);
            setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.remove(), 300); }, 50);
            setTimeout(() => gameContainer.classList.remove('shake'), 500);
        }

        function resetGame() {
            score = 0; lives = 3; level = 1; gameStarted = true; gameOver = false;
            isLevelTransitioning = false;
            lastTime = 0; 
            balls = [];
            particles = [];
            comboCount = 0;
            scoreMultiplier = 1;
            comboMultiplierDisplay = { text: '', alpha: 0, x: 0, y: 0 };
            startNextLevel();
            startBGM();
        }

        function startNextLevel() {
            levelEl.textContent = `LEVEL: ${level}`;
            invaderSpeed = LOGICAL_WIDTH * 0.00075;
            player = { x: (LOGICAL_WIDTH - PADDLE_WIDTH) / 2, y: PADDLE_Y, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, speed: LOGICAL_WIDTH * 0.0225, shieldWidth: PADDLE_WIDTH * 1.6, shieldEnhanced: false, isInvincible: false };
            
            const currentBallCount = balls.length > 0 ? balls.length : 1;
            balls = [];
            for (let i = 0; i < currentBallCount; i++) {
                 const angle = (Math.random() - 0.5) * Math.PI / 3;
                 balls.push({ x: player.x + PADDLE_WIDTH / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false });
            }
            
            lasers = []; items = []; 
            invadersMoveDirection = 1; // レベル5未満用のグローバルな方向
            invaderRowDirections = []; // レベル5以上用の列ごとの方向
            invadersMoveDown = false; 
            frameCount = 0;
            invaders = []; const invColors = ['#e71d36', '#ff9f1c', '#fca311', '#2ec4b6', '#a2d2ff'];
            for (let c = 0; c < INVADER_COLS; c++) {
                invaders[c] = [];
                for (let r = 0; r < INVADER_ROWS; r++) { 
                    const maxHealth = Math.floor(level / 5) + 1;
                    invaders[c][r] = { 
                        x: c * (INVADER_WIDTH + INVADER_PADDING) + INVADER_OFFSET_LEFT, 
                        y: r * (INVADER_HEIGHT + INVADER_PADDING) + INVADER_OFFSET_TOP, 
                        status: maxHealth,
                        maxHealth: maxHealth,
                        color: invColors[r % invColors.length], 
                        drop: null 
                    }; 
                }
            }
            
            // --- 敵の動き修正 ---
            // 列ごとの移動方向を初期化
            for (let r = 0; r < INVADER_ROWS; r++) {
                if (level >= 5) {
                    invaderRowDirections[r] = Math.random() < 0.5 ? 1 : -1;
                } else {
                    invaderRowDirections[r] = 1; // レベル5未満はすべて同じ方向
                }
            }

            let allInvaders = invaders.flat();
            for (let i = allInvaders.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allInvaders[i], allInvaders[j]] = [allInvaders[j], allInvaders[i]];
            }
            if(allInvaders.length > 0) allInvaders[0].drop = 'pierce';
            if(allInvaders.length > 1) allInvaders[1].drop = 'wideShield';
            if(allInvaders.length > 2) allInvaders[2].drop = 'invincible';
            
            updateUI();
        }
        
        function handleGameOver(isWin) {
            gameOver = true; gameStarted = false; isLevelTransitioning = false;
            stopBGM();
            document.getElementById('gameOverTitle').textContent = isWin ? "STAGE CLEAR!" : "GAME OVER";
            if (isWin) sounds.win(); else sounds.gameOver();
            if (score > highScore) { saveHighScore(score); highScore = score; }
            document.getElementById('resultLevel').textContent = level;
            document.getElementById('resultScore').textContent = score;
            document.getElementById('resultHighScore').textContent = highScore;
            
            const shareText = encodeURIComponent(`Block Raidersでレベル${level}に到達し、${score}点を獲得！あなたも挑戦してみる？ #ブロックレイダーズ`);
            const pageUrl = encodeURIComponent(GAME_URL);
            document.getElementById('shareX').href = `https://twitter.com/intent/tweet?text=${shareText}&url=${pageUrl}`;
            document.getElementById('shareFacebook').href = `https://www.facebook.com/sharer/sharer.php?u=${pageUrl}&quote=${shareText}`;
            document.getElementById('shareLine').href = `https://social-plugins.line.me/lineit/share?url=${pageUrl}&text=${shareText}`;
            
            document.getElementById('shareXAd').href = document.getElementById('shareX').href;
            document.getElementById('shareFacebookAd').href = document.getElementById('shareFacebook').href;
            document.getElementById('shareLineAd').href = document.getElementById('shareLine').href;
            
            const gameOverShareButtons = gameOverScreen.querySelector('.share-buttons');
            if(gameOverShareButtons) gameOverShareButtons.style.display = 'grid';
            
            gameOverScreen.classList.add('active');
            gameOverCount++;
        }

        function updateUI() { scoreEl.textContent = `SCORE: ${score}`; livesEl.innerHTML = `LIVES: ${'❤'.repeat(lives)}`; levelEl.textContent = `LEVEL: ${level}`; }
        
        function update(deltaTime) {
            if (isLevelTransitioning) return;

            const moveDistance = player.speed * deltaTime;
            if (rightPressed && player.x < LOGICAL_WIDTH - PADDLE_WIDTH) player.x += moveDistance;
            if (leftPressed && player.x > 0) player.x -= moveDistance;

            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                ball.x += ball.dx * deltaTime; ball.y += ball.dy * deltaTime;
                if (ball.x < BALL_RADIUS) { ball.x = BALL_RADIUS; ball.dx = Math.abs(ball.dx); }
                if (ball.x > LOGICAL_WIDTH - BALL_RADIUS) { ball.x = LOGICAL_WIDTH - BALL_RADIUS; ball.dx = -Math.abs(ball.dx); }
                if (ball.y < BALL_RADIUS) {
                    ball.y = BALL_RADIUS;
                    ball.dy = Math.abs(ball.dy);
                    if (Math.abs(ball.dy) < 0.1) ball.dy = ballSpeed * 0.1;
                }
                const barrierTop = player.y - player.height * 0.2;
                const barrierWidth = player.shieldWidth;
                const barrierX = player.x - (barrierWidth - player.width) / 2;
                if (ball.y + BALL_RADIUS > barrierTop && ball.x > barrierX && ball.x < barrierX + barrierWidth) {
                    ball.y = barrierTop - BALL_RADIUS;
                    comboCount = 0;
                    scoreMultiplier = 1;
                    let collidePoint = (ball.x - (player.x + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2);
                    let angle = collidePoint * (Math.PI / 3);
                    angle = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, angle));
                    ball.dx = ballSpeed * Math.sin(angle);
                    ball.dy = -Math.max(ballSpeed * Math.cos(angle), ballSpeed * 0.1); 
                }
                if (ball.y > LOGICAL_HEIGHT) { balls.splice(i, 1); }
            }
            if (balls.length === 0 && gameStarted && !gameOver && !isLevelTransitioning) {
                lives--;
                comboCount = 0;
                scoreMultiplier = 1;
                updateUI();
                if (lives <= 0) { 
                    handleGameOver(false); 
                } else {
                    sounds.playerHit();
                    const angle = (Math.random() - 0.5) * Math.PI / 3;
                    balls.push({ x: LOGICAL_WIDTH / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false }); 
                }
            }

            // --- 敵の動き修正 ---
            invadersMoveDown = false;
            let allDestroyed = true;

            if (level < 5) {
                // レベル5未満のロジック (全体で動く)
                let firstX = LOGICAL_WIDTH, lastX = 0;
                invaders.forEach(c => c.forEach(i => { if (i.status > 0) { allDestroyed = false; firstX = Math.min(firstX, i.x); lastX = Math.max(lastX, i.x); }}));
                if (lastX + INVADER_WIDTH > LOGICAL_WIDTH || firstX < 0) {
                    invadersMoveDirection *= -1;
                    invadersMoveDown = true;
                }
            } else {
                // レベル5以上のロジック (列ごとに動く)
                let wallHit = false;
                for (let r = 0; r < INVADER_ROWS; r++) {
                    let firstX_row = LOGICAL_WIDTH, lastX_row = 0, rowExists = false;
                     for (let c = 0; c < INVADER_COLS; c++) {
                        const invader = invaders[c][r];
                        if (invader.status > 0) {
                            rowExists = true;
                            allDestroyed = false;
                            firstX_row = Math.min(firstX_row, invader.x);
                            lastX_row = Math.max(lastX_row, invader.x);
                        }
                    }
                    if (rowExists && (lastX_row + INVADER_WIDTH > LOGICAL_WIDTH || firstX_row < 0)) {
                        invaderRowDirections[r] *= -1;
                        wallHit = true;
                    }
                }
                if (wallHit) {
                    invadersMoveDown = true;
                }
            }
            
            let reachBottom = false;
            invaders.forEach((c, colIndex) => c.forEach((invader, rowIndex) => {
                if (invader.status > 0) {
                    let moveDirection = (level < 5) ? invadersMoveDirection : invaderRowDirections[rowIndex];
                    invader.x += invaderSpeed * moveDirection * deltaTime;
                    if(invadersMoveDown) invader.y += INVADER_HEIGHT;
                    if (invader.y + INVADER_HEIGHT > player.y) reachBottom = true;
                    
                    for (let i = balls.length - 1; i >= 0; i--) {
                        const ball = balls[i];
                        const invaderHitboxX = invader.x + INVADER_WIDTH * INVADER_HITBOX_INSET_X_RATIO;
                        const invaderHitboxY = invader.y + INVADER_HEIGHT * INVADER_HITBOX_INSET_Y_RATIO;
                        const invaderHitboxWidth = INVADER_WIDTH * (1 - 2 * INVADER_HITBOX_INSET_X_RATIO);
                        const invaderHitboxHeight = INVADER_HEIGHT * (1 - 2 * INVADER_HITBOX_INSET_Y_RATIO);

                        if (ball.x + ball.radius > invaderHitboxX && ball.x - ball.radius < invaderHitboxX + invaderHitboxWidth && ball.y + ball.radius > invaderHitboxY && ball.y - ball.radius < invaderHitboxY + invaderHitboxHeight) {
                             if (!ball.isPiercing) {
                                ball.dy *= -1;
                                ball.dx += (Math.random() - 0.5) * 0.2; 
                             }
                             invader.status--;
                             comboCount++;
                             
                            if (comboCount >= 20) scoreMultiplier = 4;
                            else if (comboCount >= 10) scoreMultiplier = 3;
                            else if (comboCount >= 5) scoreMultiplier = 2;
                            else scoreMultiplier = 1;

                            if (scoreMultiplier > 1) {
                                comboMultiplierDisplay = {
                                    text: `×${scoreMultiplier}`,
                                    x: invader.x + INVADER_WIDTH / 2,
                                    y: invader.y,
                                    alpha: 1.0
                                };
                                clearTimeout(comboMultiplierDisplayTimeout);
                                comboMultiplierDisplayTimeout = setTimeout(() => {
                                    if(comboMultiplierDisplay) comboMultiplierDisplay.alpha = 0;
                                }, 1000);
                            }
                             
                             if(invader.status <= 0){
                                sounds.destroy();
                                createExplosion(invader.x + INVADER_WIDTH / 2, invader.y + INVADER_HEIGHT / 2, invader.color);
                                score += (10 * invader.maxHealth) * scoreMultiplier;
                                if (invader.drop) {
                                     items.push({x: invader.x + INVADER_WIDTH / 2, y: invader.y, type: invader.drop});
                                     invader.drop = null;
                                } else if (Math.random() < ITEM_DROP_CHANCE) {
                                     const itemType = Math.random() < MULTIBALL_CHANCE && balls.length < 3 ? 'multiBall' : 'life';
                                     items.push({x: invader.x + INVADER_WIDTH / 2, y: invader.y, type: itemType});
                                }
                             } else {
                                sounds.hit();
                             }
                             updateUI();
                             break;
                        }
                    }
                }
            }));

            if(reachBottom) { handleGameOver(false); return; }
            if(allDestroyed && gameStarted && !gameOver && !isLevelTransitioning) {
                isLevelTransitioning = true;
                level++;
                sounds.win();
                setTimeout(() => { startNextLevel(); isLevelTransitioning = false; }, 1500);
                return;
            }

            frameCount++;
            if (frameCount % (Math.max(20, 90 - level * 4)) === 0 && Math.random() < (0.15 + level * 0.04)) {
                let shooters = []; invaders.forEach(c => { for(let r=INVADER_ROWS-1; r>=0; r--) { if(c[r].status > 0) { shooters.push(c[r]); break; }}});
                if(shooters.length > 0) { const s = shooters[Math.floor(Math.random() * shooters.length)]; lasers.push({x: s.x + INVADER_WIDTH / 2 - LASER_WIDTH / 2, y: s.y + INVADER_HEIGHT }); sounds.laser(); }
            }
            lasers.forEach((l, i) => {
                l.y += laserSpeed * deltaTime; if (l.y > LOGICAL_HEIGHT) lasers.splice(i, 1);
                if (player.isInvincible) return;
                const playerHitboxX = player.x + PADDLE_WIDTH * PLAYER_HITBOX_INSET_X_RATIO;
                const playerHitboxY = player.y + PADDLE_HEIGHT * PLAYER_HITBOX_INSET_Y_RATIO;
                const playerHitboxWidth = PADDLE_WIDTH * (1 - 2 * PLAYER_HITBOX_INSET_X_RATIO);
                const playerHitboxHeight = PADDLE_HEIGHT * (1 - PLAYER_HITBOX_INSET_Y_RATIO);
                if (l.y + LASER_HEIGHT > playerHitboxY && l.y < playerHitboxY + playerHitboxHeight && l.x + LASER_WIDTH > playerHitboxX && l.x < playerHitboxX + playerHitboxWidth) {
                     lasers.splice(i, 1); lives--; sounds.playerHit(); triggerScreenEffect(); if (lives <= 0) handleGameOver(false); updateUI();
                }
            });
            items.forEach((item, i) => {
                item.y += itemSpeed * deltaTime; if (item.y > LOGICAL_HEIGHT) items.splice(i, 1);
                const itemHitboxX = item.x - ITEM_SIZE / 2;
                const itemHitboxY = item.y - ITEM_SIZE / 2;
                if(itemHitboxY + ITEM_SIZE > player.y && itemHitboxY < player.y + PADDLE_HEIGHT && itemHitboxX + ITEM_SIZE > player.x && itemHitboxX < player.x + PADDLE_WIDTH) {
                     if(item.type === 'life' && lives < 5) { lives++; sounds.getLife(); }
                     else if (item.type === 'multiBall') {
                         sounds.getMultiBall();
                         if (balls.length < 3) {
                             const angle = (Math.random() - 0.5) * Math.PI / 3;
                             balls.push({ x: player.x + player.width / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false });
                         }
                     } else if (item.type === 'pierce') {
                         sounds.getPierce();
                         balls.forEach(b => b.isPiercing = true);
                         if (pierceTimeoutId) clearTimeout(pierceTimeoutId);
                         pierceTimeoutId = setTimeout(() => { balls.forEach(b => b.isPiercing = false); }, PIERCE_DURATION);
                     } else if(item.type === 'wideShield') {
                         sounds.getShield();
                         player.shieldEnhanced = true;
                         player.shieldWidth = PADDLE_WIDTH * 2.2;
                         if(shieldTimeoutId) clearTimeout(shieldTimeoutId);
                         shieldTimeoutId = setTimeout(() => { player.shieldWidth = PADDLE_WIDTH * 1.6; player.shieldEnhanced = false; }, SHIELD_EXPAND_DURATION);
                     } else if (item.type === 'invincible') {
                         sounds.getInvincible();
                         player.isInvincible = true;
                         if(invincibleTimeoutId) clearTimeout(invincibleTimeoutId);
                         invincibleTimeoutId = setTimeout(() => { player.isInvincible = false; }, INVINCIBLE_DURATION);
                     }
                     items.splice(i, 1);
                     updateUI();
                }
            });
            
            if (comboMultiplierDisplay && comboMultiplierDisplay.alpha > 0) {
                 comboMultiplierDisplay.alpha -= 0.01;
            }
        }
        
        function draw() {
            if(!ctx) return;
            const dpr = window.devicePixelRatio || 1;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore(); 

            drawStars();
            drawInvaders();
            drawLasers();
            drawItems();
            drawPlayer();
            drawBalls();
            drawParticles();
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameStarted) {
                cancelAnimationFrame(animationFrameId);
                return;
            };

            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 16.67;
            
            update(deltaTime);
            draw();
            drawScoreMultiplier(); 

            lastTime = timestamp;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => { if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true; else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true; });
        document.addEventListener('keyup', e => { if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false; else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false; });
        
        document.addEventListener('mousemove', e => {
            if(!gameStarted || gameOver || !player) return;
            const rect = canvas.getBoundingClientRect();
            let newX = (e.clientX - rect.left) / rect.width * LOGICAL_WIDTH - (player.width / 2);
            player.x = Math.max(0, Math.min(newX, LOGICAL_WIDTH - player.width));
        });

        canvas.addEventListener('touchstart', e => { e.preventDefault(); touchStartX = e.touches[0].clientX; }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(touchStartX === null || !gameStarted || gameOver || !player) return;
            const rect = canvas.getBoundingClientRect();
            const currentX = e.touches[0].clientX;
            const diffX = (currentX - touchStartX) * (LOGICAL_WIDTH / rect.width);
            player.x += diffX;
            player.x = Math.max(0, Math.min(player.x, LOGICAL_WIDTH - PADDLE_WIDTH));
            touchStartX = currentX;
        }, { passive: false });
        canvas.addEventListener('touchend', e => { e.preventDefault(); touchStartX = null; });
        
        muteButton.addEventListener('click', () => {
            sounds.buttonClick();
            Tone.Master.mute = !Tone.Master.mute;
            muteButton.textContent = `SOUND: ${Tone.Master.mute ? 'OFF' : 'ON'}`;
            soundCheckbox.checked = !Tone.Master.mute;
        });
        
        soundCheckbox.addEventListener('change', () => {
            Tone.Master.mute = !soundCheckbox.checked;
            muteButton.textContent = `SOUND: ${Tone.Master.mute ? 'OFF' : 'ON'}`;
        });

        startButton.addEventListener('click', async () => { 
            sounds.buttonClick();
            if (!audioInitialized) {
                try {
                    await Tone.start();
                    audioInitialized = true;
                    console.log("[DEBUG] AudioContext started by user gesture.");
                } catch(e) {
                    console.error("[ERROR] Could not start AudioContext on click:", e);
                }
            }
            startScreen.classList.remove('active');
            resetGame();
            requestAnimationFrame(gameLoop);
        });
        restartButton.addEventListener('click', () => {
            sounds.buttonClick();
            gameOverScreen.classList.remove('active');
            lastTime = 0;
            if (hasSharedEver) {
                resetGame();
                requestAnimationFrame(gameLoop);
            } else {
                playAdSimulation();
            }
        });

        function handleShareClick(e) { 
            hasSharedEver = true; 
            localStorage.setItem('blockRaidersShared', 'true');
            bottomBannerAd.style.display = 'none';
            clearInterval(bannerInterval);
        }

        document.querySelectorAll('.share-buttons a').forEach(button => button.addEventListener('click', handleShareClick));
        
        function playAdSimulation() {
            adScreen.classList.add('active');
            const ad1 = `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+5YZ75" rel="nofollow"><img border="0" width="300" height="250" alt="" src="https://www23.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001003000&mc=1"></a><img border="0" width="1" height="1" src="https://www12.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+5YZ75" alt="">`;
            const ad2 = `<a href="https://click.duga.jp/aff/48328-01" target="_blank"><img src="https://ad.duga.jp/banner/aff/300-250.gif" alt="APEX アフィリエイト システム"></a>`;
            adContainer.innerHTML = (gameOverCount % 2 !== 0) ? ad1 : ad2;

            let timeLeft = 7;
            adTimerEl.textContent = `リトライまで ${timeLeft} 秒`;
            adRestartButton.style.display = "none";

            adTimerInterval = setInterval(() => {
                timeLeft--;
                adTimerEl.textContent = `リトライまで ${timeLeft} 秒`;
                if (timeLeft <= 0) {
                    clearInterval(adTimerInterval);
                    adTimerEl.textContent = "";
                    adRestartButton.style.display = "block";
                }
            }, 1000);
        }

        adRestartButton.addEventListener('click', () => {
            adScreen.classList.remove('active');
            resetGame();
            requestAnimationFrame(gameLoop);
        });
        
        function resizeCanvas() {
            const gameWrapper = document.getElementById('game-wrapper');
            const uiContainer = document.getElementById('uiContainer');
            if(!gameWrapper || !gameContainer) return;
            const { width, height } = gameWrapper.getBoundingClientRect();
            
            const wrapperStyle = window.getComputedStyle(gameWrapper);
            const wrapperPaddingLeft = parseFloat(wrapperStyle.paddingLeft);
            const wrapperPaddingRight = parseFloat(wrapperStyle.paddingRight);
            const contentWidth = width - wrapperPaddingLeft - wrapperPaddingRight;
            uiContainer.style.width = `${contentWidth}px`;
            
            const aspectRatio = LOGICAL_WIDTH / LOGICAL_HEIGHT;
            let newWidth = contentWidth;
            let newHeight = newWidth / aspectRatio;

            const gameContainerHeight = gameWrapper.clientHeight - uiContainer.offsetHeight;

            if (newHeight > gameContainerHeight) {
                newHeight = gameContainerHeight;
                newWidth = newHeight * aspectRatio;
            }
            
            gameContainer.style.width = `${newWidth}px`;
            gameContainer.style.height = `${newHeight}px`;
            
            if(newWidth < contentWidth) {
                uiContainer.style.width = `${newWidth}px`;
            } else {
                 uiContainer.style.width = `${contentWidth}px`;
            }


            const dpr = window.devicePixelRatio || 1;
            canvas.width = LOGICAL_WIDTH * dpr;
            canvas.height = LOGICAL_HEIGHT * dpr;
            
            if(ctx) {
                ctx.scale(dpr, dpr);
            }

            PADDLE_WIDTH = LOGICAL_WIDTH * PADDLE_WIDTH_RATIO;
            PADDLE_HEIGHT = LOGICAL_HEIGHT * PADDLE_HEIGHT_RATIO;
            BALL_RADIUS = LOGICAL_WIDTH * BALL_RADIUS_RATIO;
            LASER_WIDTH = LOGICAL_WIDTH * LASER_WIDTH_RATIO;
            LASER_HEIGHT = LOGICAL_HEIGHT * LASER_HEIGHT_RATIO;
            ITEM_SIZE = LOGICAL_WIDTH * ITEM_SIZE_RATIO;
            PADDLE_Y = LOGICAL_HEIGHT - PADDLE_HEIGHT * 2.5;

            INVADER_WIDTH = LOGICAL_WIDTH * 0.075;
            INVADER_HEIGHT = LOGICAL_HEIGHT * 0.04;
            INVADER_PADDING = LOGICAL_WIDTH * 0.025;
            INVADER_OFFSET_TOP = LOGICAL_HEIGHT * 0.083;
            INVADER_OFFSET_LEFT = (LOGICAL_WIDTH - (INVADER_COLS * (INVADER_WIDTH + INVADER_PADDING))) / 2;
            
            ballSpeed = LOGICAL_HEIGHT * BASE_SPEED;
            laserSpeed = LOGICAL_HEIGHT * BASE_SPEED;
            itemSpeed = LOGICAL_HEIGHT * (BASE_SPEED / 2.5);
        }
        
        window.onresize = resizeCanvas;
        
        const bannerAds = [
            `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+5ZU29" rel="nofollow"><img border="0" width="320" height="50" alt="" src="https://www20.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001007000&mc=1"></a><img border="0" width="1" height="1" src="https://www10.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+5ZU29" alt="">`,
            `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+601S1" rel="nofollow"><img border="0" width="320" height="50" alt="" src="https://www21.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001008000&mc=1"></a><img border="0" width="1" height="1" src="https://www17.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+601S1" alt="">`
        ];
        let currentAdIndex = 0;
        let bannerInterval;

        function showBannerAd() {
            if(hasSharedEver) return;
            bannerContent.innerHTML = bannerAds[currentAdIndex];
            bottomBannerAd.style.display = 'flex';
            currentAdIndex = (currentAdIndex + 1) % bannerAds.length;
        }
        
        function startBannerRotation() {
            if(hasSharedEver || bannerInterval) return;
            showBannerAd();
            bannerInterval = setInterval(showBannerAd, 10000);
        }

        if(closeBannerBtn) {
            closeBannerBtn.addEventListener('click', () => {
                bottomBannerAd.style.display = 'none';
                clearInterval(bannerInterval);
            });
        }

        async function initGame() {
            await initializeFirebase(); 
            
            if(canvas.getContext) {
                ctx = canvas.getContext('2d');
            }
            if(!ctx) {
                console.error("2D context not supported");
                return;
            }
            resizeCanvas(); 
            drawStars();
            
            console.log("[DEBUG] Initializing BGM & SFX loading...");
            startButton.disabled = true;
            try {
                 await Promise.all([
                    bgmPlayer.load(BGM_URL),
                    new Promise(res => { buttonClickBuffer = new Tone.Buffer(BUTTON_CLICK_URL, res); }),
                    new Promise(res => { hitBuffer = new Tone.Buffer(ENEMY_HIT_URL, res); }),
                    new Promise(res => { destroyBuffer = new Tone.Buffer(ENEMY_DEATH_URL, res); }),
                    new Promise(res => { playerHitBuffer = new Tone.Buffer(PLAYER_HIT_URL, res); }),
                    new Promise(res => { healBuffer = new Tone.Buffer(HEAL_URL, res); }),
                    new Promise(res => { itemBuffer = new Tone.Buffer(POWERUP_URL, res); })
                ]);
                console.log("[DEBUG] All audio buffers loaded successfully.");
                startButton.disabled = false;
                startButton.textContent = "START GAME";
                if (!hasSharedEver) {
                    startBannerRotation();
                }
            } catch(e) {
                console.error("[ERROR] Failed to load sounds.", e);
                startButton.textContent = "START (NO SOUND)";
                startButton.disabled = false;
            }
        }

        initGame();
    });

    </script>
</body>
</html>
