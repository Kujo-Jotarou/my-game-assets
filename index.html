<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Raiders</title>

    <!-- OGPタグの追加 -->
    <meta property="og:title" content="Block Raiders">
    <meta property="og:description" content="A retro arcade-style block-breaking game. Break all the blocks and aim for a high score!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kujo-jotarou.github.io/my-game-assets/">
    <meta property="og:image" content="https://placehold.co/1200x630/1a1a2e/fca311/png?text=BLOCK%20RAIDERS&font=orbitron">
    <meta name="twitter:card" content="summary_large_image">
    <!-- OGPタグここまで -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        /* 基本的なページスタイル */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Press Start 2P', 'Courier New', Courier, monospace;
        }
        body.with-banner {
            padding-bottom: 40px; /* バナーの高さ分 */
            box-sizing: border-box;
        }
        /* ゲーム全体を中央に配置するためのコンテナ */
        #game-wrapper {
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            padding: 10px;
            box-sizing: border-box;
        }
        /* スコアやライフなどのUIコンテナ */
        #uiContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 5px 0;
            font-size: 14px;
            flex-shrink: 0;
        }
        /* ゲームのメイン描画領域 */
        #gameContainer {
            position: relative;
            width: 100%;
            flex-grow: 1;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(252, 163, 17, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }
        /* ゲーム用キャンバス */
        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #0f0f1b;
        }
        
        #logo-image {
             position: absolute;
             top: 15%;
             left: 50%;
             transform: translateX(-50%);
             width: 80%;
             max-width: 400px;
             height: auto;
             z-index: 12;
        }
        #lives {
            color: #ff4d6d;
            font-weight: bold;
        }
        #muteButton {
            background: #33415c;
            border: 2px solid #4a5568;
            color: #e0e0e0;
            padding: 5px 10px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
        }
        /* スタート・ゲームオーバー等の画面スタイル */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 46, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s 0.3s, opacity 0.3s linear;
            z-index: 10;
            border-radius: 10px;
        }
        #startScreen {
             background-color: rgba(26, 26, 46, 0.7);
             z-index: 11;
        }
        .screen.active {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s linear;
        }
        .screen h2 { font-size: 40px; margin-bottom: 20px; color: #fca311; }
        .screen p { font-size: 20px; margin: 10px 0; }
        .screen button { background-color: #fca311; color: #1a1a2e; border: none; padding: 15px 30px; font-size: 20px; font-family: 'Press Start 2P', 'Courier New', Courier, monospace; border-radius: 8px; cursor: pointer; text-transform: uppercase; transition: all 0.2s; box-shadow: 0 4px 0 #c87e07; margin-top: 20px; }
        .screen button:hover { transform: translateY(-2px); box-shadow: 0 6px 0 #c87e07; }
        .screen button:active { transform: translateY(2px); box-shadow: 0 2px 0 #c87e07; }
        
        .share-buttons { 
            margin-top: 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 260px;
        }
        .share-buttons-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }
        .share-buttons a {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 5px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: transform 0.2s;
            text-align: center;
            flex: 1;
        }
        .share-x { background-color: #000000; }
        .share-facebook { background-color: #1877F2; }
        .share-line { background-color: #00B900; }
        .share-tiktok { background-color: #000000; }
        .share-instagram { background: #d6249f; background: radial-gradient(circle at 30% 107%, #fdf497 0%, #fdf497 5%, #fd5949 45%,#d6249f 60%,#285AEB 90%); }


        #adContainer a { display: block; margin-bottom: 15px;}
        #sound-toggle-container { margin-top: 25px; }
        #sound-toggle { display: flex; align-items: center; justify-content: center; font-size: 14px; }
        #sound-toggle label { margin-right: 10px; }
        
        #bottom-banner-ad {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0,0,0,0.8);
            padding: 0;
            box-sizing: border-box;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-shrink: 0;
            height: 40px;
            overflow: hidden;
        }
        #banner-content {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        #banner-content img {
            max-height: 100%;
            width: auto;
        }
        #close-banner-btn {
            font-size: 10px;
            padding: 5px 8px;
            margin-left: 15px;
            background: #ff4d6d;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
        }
        
        #pauseButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            background-color: rgba(74, 85, 104, 0.7);
            border: 1px solid #e0e0e0;
            color: #e0e0e0;
            width: 35px;
            height: 35px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            line-height: 35px;
            text-align: center;
            padding: 0;
            display: none;
        }
        #pauseScreen h2 {
            text-shadow: 2px 2px 4px #000;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        
        @media (max-width: 480px) {
            #uiContainer {
                font-size: 12px;
            }
            #muteButton {
                font-size: 10px;
                padding: 4px 8px;
            }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="uiContainer">
            <div>
                <span id="score">SCORE: 0</span><br>
                <span id="level">LEVEL: 1</span>
            </div>
            <div id="lives">LIVES: 3</div>
            <button id="muteButton">SOUND: ON</button>
        </div>
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <button id="pauseButton">||</button>
            <div id="startScreen" class="screen active">
                <img id="logo-image" src="https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E3%82%AA%E3%83%BC%E3%83%97%E3%83%8B%E3%83%B3%E3%82%B0.png" alt="Block Raiders Logo">
                <div style="position: absolute; bottom: 10%; width: 100%; text-align: center;">
                    <p>High Score: <span id="startHighScore">0</span></p>
                    <button id="startButton" disabled>LOADING...</button>
                    <div id="sound-toggle-container">
                        <div id="sound-toggle">
                             <label for="sound-checkbox">SOUND</label>
                        <input type="checkbox" id="sound-checkbox" checked>
                    </div>
                </div>
            </div>
            <div id="gameOverScreen" class="screen">
                <h2 id="gameOverTitle">GAME OVER</h2>
                <p>LEVEL: <span id="resultLevel">1</span></p>
                <p>SCORE: <span id="resultScore">0</span></p>
                <p>HIGH SCORE: <span id="resultHighScore">0</span></p>
                <button id="restartButton">もう一度プレイ</button>
                <div class="share-buttons">
                    <div class="share-buttons-row">
                        <a id="shareX" class="share-x" href="#" target="_blank">X</a>
                        <a id="shareFacebook" class="share-facebook" href="#" target="_blank">Facebook</a>
                        <a id="shareLine" class="share-line" href="#" target="_blank">LINE</a>
                    </div>
                    <div class="share-buttons-row">
                         <a id="shareTikTok" class="share-tiktok" href="https://www.tiktok.com/" target="_blank">TikTok</a>
                        <a id="shareInstagram" class="share-instagram" href="https://www.instagram.com/" target="_blank">Instagram</a>
                    </div>
                </div>
            </div>
            <div id="pauseScreen" class="screen">
                <h2>PAUSED</h2>
            </div>
             <div id="adScreen" class="screen">
                <div id="adContainer">
                   </div>
                <p><span id="adTimer"></span></p>
                <button id="adRestartButton" style="display:none;">もう一度プレイ</button>
                 <div class="share-buttons">
                     <p style="font-size: 14px; margin-bottom: 10px; grid-column: 1 / -1; width: 100%; text-align: center;">シェアで今後表示しない</p>
                    <div class="share-buttons-row">
                        <a id="shareXAd" class="share-x" href="#" target="_blank">X</a>
                        <a id="shareFacebookAd" class="share-facebook" href="#" target="_blank">Facebook</a>
                        <a id="shareLineAd" class="share-line" href="#" target="_blank">LINE</a>
                    </div>
                    <div class="share-buttons-row">
                         <a id="shareTikTokAd" class="share-tiktok" href="https://www.tiktok.com/" target="_blank">TikTok</a>
                        <a id="shareInstagramAd" class="share-instagram" href="https://www.instagram.com/" target="_blank">Instagram</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="bottom-banner-ad">
        <span id="banner-content"></span>
        <button id="close-banner-btn">×</button>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM要素の取得
        const canvas = document.getElementById('gameCanvas');
        let ctx; 
        const gameContainer = document.getElementById('gameContainer');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const muteButton = document.getElementById('muteButton');
        const soundCheckbox = document.getElementById('sound-checkbox');
        const adScreen = document.getElementById('adScreen');
        const adTimerEl = document.getElementById('adTimer');
        const adRestartButton = document.getElementById('adRestartButton');
        const bottomBannerAd = document.getElementById('bottom-banner-ad');
        const adContainer = document.getElementById('adContainer');
        const bannerContent = document.getElementById('banner-content');
        const closeBannerBtn = document.getElementById('close-banner-btn');
        const pauseButton = document.getElementById('pauseButton');
        const pauseScreen = document.getElementById('pauseScreen');
        
        // 論理的なゲーム画面サイズ
        const LOGICAL_WIDTH = 480;
        const LOGICAL_HEIGHT = 600;

        // レスポンシブ対応のゲーム要素サイズ比率
        const PADDLE_WIDTH_RATIO = 0.2; 
        const PADDLE_HEIGHT_RATIO = 0.04;
        const BALL_RADIUS_RATIO = 0.013; 
        const LASER_WIDTH_RATIO = 0.01;
        const LASER_HEIGHT_RATIO = 0.025;
        const BASE_ITEM_SIZE_RATIO = 0.04 * 2; 
        
        let PADDLE_WIDTH, PADDLE_HEIGHT, BALL_RADIUS, LASER_WIDTH, LASER_HEIGHT, PADDLE_Y;
        let itemSizes = {}; 

        const INVADER_ROWS = 5, INVADER_COLS = 8;
        let INVADER_WIDTH, INVADER_HEIGHT, INVADER_PADDING, INVADER_OFFSET_TOP, INVADER_OFFSET_LEFT;
        
        // ヒットボックスの調整比率
        const INVADER_HITBOX_INSET_X_RATIO = 0.11;
        const INVADER_HITBOX_INSET_Y_RATIO = 0.08;
        const PLAYER_HITBOX_INSET_X_RATIO = 0.18;
        const PLAYER_HITBOX_INSET_Y_RATIO = 0.18;

        let ballSpeed, laserSpeed, itemSpeed;

        // ゲームバランス定数
        const PIERCE_DURATION = 8000;
        const SHIELD_EXPAND_DURATION = 10000;
        const INVINCIBLE_DURATION = 8000;
        
        // アセットURL
        const GAME_URL = "https://kujo-jotarou.github.io/my-game-assets/";
        const BGM_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/bgm.MP3";
        const BUTTON_CLICK_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E3%83%9C%E3%82%BF%E3%83%B3.mp3";
        const ENEMY_DEATH_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E6%95%B5%E6%AD%BB%E4%BA%A1.mp3";
        const ENEMY_HIT_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E6%95%B5%E8%A2%AB%E5%BC%BE.mp3";
        const PLAYER_HIT_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E8%A2%AB%E5%BC%BE.mp3";
        const PADDLE_HIT_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E5%BC%BE%E3%81%8D.mp3";
        const HEAL_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E5%9B%9E%E5%BE%A9.mp3";
        const POWERUP_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/%E3%83%91%E3%83%AF%E3%83%BC%E3%82%A2%E3%83%83%E3%83%97.mp3";
        const UFO_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/UFO.mp3";
        const UFO_LASER_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/UFO%E3%83%AC%E3%83%BC%E3%82%B6%E3%83%BC.mp3";
        const UFO_DEATH_URL = "https://cdn.jsdelivr.net/gh/Kujo-Jotarou/my-game-assets@main/UFO%E6%92%83%E7%A0%B4.mp3";

        const ICON_URLS = {
            life: 'https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E3%83%8F%E3%83%BC%E3%83%88%E9%80%8F%E9%81%8E.png',
            invincible: 'https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E7%84%A1%E6%95%B5%E9%80%8F%E9%81%8E.png',
            multiBall: 'https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E5%BC%BE%E5%A2%97%E5%8A%A0%E9%80%8F%E9%81%8E.png',
            pierce: 'https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E8%B2%AB%E9%80%9A%E5%BC%BE%E9%80%8F%E9%81%8E.png',
            wideShield: 'https://raw.githubusercontent.com/Kujo-Jotarou/my-game-assets/main/%E5%B9%85UP%E9%80%8F%E9%81%8E.png'
        };
        const itemImages = {};


        // ゲームオブジェクトと状態変数
        let player, balls, invaders, lasers, ufo, ufoLasers, items, particles, stars;
        let score, lives, level, highScore = 0;
        let rightPressed = false, leftPressed = false;
        let gameState = 'START'; // 'START', 'PLAYING', 'PAUSED', 'GAMEOVER'
        let invadersMoveDirection = 1;
        let invaderRowDirections = [];
        let frameCount = 0;
        let isLevelTransitioning = false;
        let levelStartGracePeriod = false;
        let pierceTimeoutId = null;
        let shieldTimeoutId = null;
        let invincibleTimeoutId = null;
        let touchStartX = null;
        let hasSharedEver = localStorage.getItem('blockRaidersShared') === 'true';
        let adTimerInterval = null;
        let audioInitialized = false;
        let gameOverCount = 0;
        let animationLoopId;
        
        let comboMultiplierDisplay, comboMultiplierDisplayTimeout;
        let comboCount = 0;
        
        let wideShieldDropsThisStage = 0;
        let heartDropsThisStage = 0;
        let invincibleDropsThisStage = 0;
        let multiBallDropsThisStage = 0;
        let pierceDropsThisStage = 0;

        // Firebase関連
        let db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Tone.js サウンドエンジン
        const sfxBus = new Tone.Channel().toDestination();
        const melodySynth = new Tone.Synth({volume: -4}).connect(sfxBus);

        let hitBuffer, destroyBuffer, playerHitBuffer, itemBuffer, healBuffer, buttonClickBuffer, ufoBuffer, ufoLaserBuffer, ufoDestroyBuffer, paddleHitBuffer;
        
        let ufoSoundPlayer = null;

        function playSound(buffer, duration) {
            if (!audioInitialized || Tone.Master.mute || !buffer) return;
            const player = new Tone.Player(buffer).toDestination();
            player.connect(sfxBus);
            player.start(Tone.now(), 0, duration);
             setTimeout(() => {
                if(player && !player.disposed){
                    player.dispose();
                }
            }, (duration || buffer.duration) * 1000 + 100); 
        }

        const sounds = {
            hit: () => playSound(hitBuffer),
            destroy: () => playSound(destroyBuffer),
            laser: () => {
                if (!audioInitialized || Tone.Master.mute) return;
                const laserSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 } }).connect(sfxBus);
                laserSynth.volume.value = -18;
                const now = Tone.now();
                laserSynth.triggerAttack(now);
                laserSynth.frequency.setValueAtTime("A5", now);
                laserSynth.frequency.rampTo("A4", now + 0.2);
                laserSynth.triggerRelease(now + 0.2);
                setTimeout(() => laserSynth.dispose(), 300);
            },
            playerHit: () => playSound(playerHitBuffer),
            paddleHit: () => playSound(paddleHitBuffer),
            getItem: () => playSound(itemBuffer),
            getLife: () => playSound(healBuffer),
            getMultiBall: () => playSound(itemBuffer),
            getPierce: () => playSound(itemBuffer),
            getShield: () => playSound(itemBuffer),
            getInvincible: () => playSound(itemBuffer),
            buttonClick: () => playSound(buttonClickBuffer),
            ufoLaser: () => playSound(ufoLaserBuffer, 1),
            ufoDestroy: () => playSound(ufoDestroyBuffer),
            gameOver: () => { const now = Tone.now(); melodySynth.triggerAttackRelease('G3', '8n', now); melodySynth.triggerAttackRelease('F#3', '8n', now + 0.1); melodySynth.triggerAttackRelease('F3', '8n', now + 0.2); melodySynth.triggerAttackRelease('E3', '4n', now + 0.3); },
            win: () => { const now = Tone.now(); melodySynth.triggerAttackRelease('C5', '8n', now); melodySynth.triggerAttackRelease('E5', '8n', now + 0.1); melodySynth.triggerAttackRelease('G5', '8n', now + 0.2); melodySynth.triggerAttackRelease('C6', '4n', now + 0.3); }
        };

        const bgmPlayer = new Tone.Player({
            loop: true,
            volume: -12,
        }).toDestination();
        
        function startBGM() { 
            if (bgmPlayer.loaded && bgmPlayer.state !== 'started' && !Tone.Master.mute) { 
                bgmPlayer.start(); 
            } 
        }
        function stopBGM() { 
            if(bgmPlayer.state === 'started') { 
                bgmPlayer.stop(); 
            }
        }

        async function initializeFirebase() {
             try {
                if (typeof firebase === 'undefined' || typeof __firebase_config === 'undefined') {
                    throw new Error("Firebase config not available");
                }
                const firebaseConfig = JSON.parse(__firebase_config);
                 if (!firebaseConfig.projectId) throw new Error("Firebase projectId is missing in config");
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
                
                const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if(token) {
                    await auth.signInWithCustomToken(token);
                } else {
                    await auth.signInAnonymously();
                }
                userId = auth.currentUser.uid;
                await loadHighScore();

            } catch (e) { 
                console.warn("Firebase init failed, falling back to local storage:", e.message); 
                userId = `local-${crypto.randomUUID()}`;
                loadHighScore();
            }
        }
        async function loadHighScore() {
            if (!userId) return;
            if (db) {
                try {
                    const docRef = db.collection(`artifacts/${appId}/users/${userId}/highscores`).doc("gameData");
                    const docSnap = await docRef.get();
                    if (docSnap.exists) { highScore = docSnap.data().score || 0; }
                } catch (e) {
                    console.warn("Firestore load failed, using local storage:", e);
                    highScore = parseInt(localStorage.getItem('blockRaidersHighScore') || '0', 10);
                }
            } else {
                highScore = parseInt(localStorage.getItem('blockRaidersHighScore') || '0', 10);
            }
            document.getElementById('startHighScore').textContent = highScore;
            document.getElementById('resultHighScore').textContent = highScore;
        }
        async function saveHighScore(newScore) {
            if (!userId) return;
            if (db) {
                try {
                    await db.collection(`artifacts/${appId}/users/${userId}/highscores`).doc("gameData").set({ score: newScore });
                } catch (e) {
                    console.warn("Firestore save failed, using local storage:", e);
                    localStorage.setItem('blockRaidersHighScore', newScore);
                }
            } else {
                 localStorage.setItem('blockRaidersHighScore', newScore);
            }
        }
        
        function drawPlayerShape(x, y, width, height) {
            const w = width / 12;
            const h = height / 10;
        
            ctx.fillStyle = "#B0C4DE";
            const mainBody = [
                [0,0,0,0,0,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,0,0,1,1,0,0,1,1,0],
            ];
            for (let row = 0; row < mainBody.length; row++) {
                for (let col = 0; col < mainBody[row].length; col++) {
                    if (mainBody[row][col]) {
                        ctx.fillRect(x + col * w, y + row * h, w, h);
                    }
                }
            }
            
            ctx.fillStyle = "#4682B4";
            const wings = [
                [1,1,0,0,0,0,0,0,0,0,1,1],
                [0,1,1,0,0,0,0,0,0,1,1,0]
            ];
             for (let row = 0; row < wings.length; row++) {
                for (let col = 0; col < wings[row].length; col++) {
                    if (wings[row][col]) {
                        ctx.fillRect(x + col * w, y + (3 + row) * h, w, h);
                    }
                }
            }

            ctx.fillStyle = "#FF6347";
            const cockpit = [
                [0,0,0,0,1,1,1,1,0,0,0,0]
            ];
             for (let row = 0; row < cockpit.length; row++) {
                for (let col = 0; col < cockpit[row].length; col++) {
                    if (cockpit[row][col]) {
                        ctx.fillRect(x + col * w, y + (2 + row) * h, w, h);
                    }
                }
            }
        
            const flameColors = ['#FF4500', '#FFD700', '#FFA500'];
            const flameIndex = Math.floor(frameCount / 4) % flameColors.length;
            ctx.fillStyle = flameColors[flameIndex];
            
            const flameHeight1 = h * (2.0 + (frameCount % 5 === 0 ? Math.random() * 0.8 : 0.4));
            const flameHeight2 = h * (2.0 + (frameCount % 6 === 0 ? Math.random() * 0.8 : 0.5));
            ctx.fillRect(x + 5 * w, y + 6 * h, w, flameHeight1);
            ctx.fillRect(x + 6 * w, y + 6 * h, w, flameHeight2);
        }
        
        function drawPlayer() {
            ctx.save();
            if(player.isInvincible) {
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 80) * 0.2;
                ctx.shadowColor = `hsl(${Date.now() / 20 % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
            }
            drawPlayerShape(player.x, player.y, player.width, player.height);
            ctx.restore();
            const barrierWidth = player.shieldWidth;
            const barrierX = player.x - (barrierWidth - player.width) / 2;
            const barrierY = player.y - player.height * 0.2;
            ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.3;
            let grad, shadowColor;
            if (player.shieldEnhanced) {
                grad = ctx.createLinearGradient(barrierX, barrierY, barrierX + barrierWidth, barrierY);
                grad.addColorStop(0, "rgba(255, 0, 0, 0)");
                grad.addColorStop(0.2, "rgba(255, 69, 0, 0.8)");
                grad.addColorStop(0.8, "rgba(255, 69, 0, 0.8)");
                grad.addColorStop(1, "rgba(255, 0, 0, 0)");
                shadowColor = '#ff4500';
            } else {
                grad = ctx.createLinearGradient(barrierX, barrierY, barrierX + barrierWidth, barrierY);
                grad.addColorStop(0, "rgba(0, 225, 255, 0)");
                grad.addColorStop(0.2, "rgba(173, 216, 230, 0.8)");
                grad.addColorStop(0.8, "rgba(173, 216, 230, 0.8)");
                grad.addColorStop(1, "rgba(0, 225, 255, 0)");
                shadowColor = '#00e1ff';
            }
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 15;
            ctx.fillStyle = grad;
            ctx.fillRect(barrierX, barrierY, barrierWidth, 6);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1.0;
             if (player.paddleHit.active) {
                ctx.save();
                ctx.globalAlpha = player.paddleHit.alpha;
                
                const flashGrad = ctx.createRadialGradient(
                    player.x + player.width / 2, barrierY + 3, 0,
                    player.x + player.width / 2, barrierY + 3, (barrierWidth * 1.5)/2
                );
                flashGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                flashGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = flashGrad;

                const expandedWidth = barrierWidth * 1.5;
                const expandedX = player.x - (expandedWidth - player.width) / 2;
                
                ctx.fillRect(expandedX, barrierY - 2, expandedWidth, 10);
                ctx.restore();
            }
        }

        function drawBall(ball) {
            ctx.save();
            if (ball.isGolden) {
                 const goldenColor = `hsl(${frameCount % 360}, 100%, 75%)`;
                 ctx.fillStyle = goldenColor;
                 ctx.shadowColor = goldenColor;
                 ctx.shadowBlur = 25;
            } else if (ball.isPiercing) {
                const grad = ctx.createRadialGradient(ball.x, ball.y, ball.radius * 0.2, ball.x, ball.y, ball.radius);
                grad.addColorStop(0, '#FFFFFF');
                grad.addColorStop(0.7, '#C9A0DC');
                grad.addColorStop(1, '#9400D3');
                ctx.fillStyle = grad;
                ctx.shadowColor = '#C9A0DC';
                ctx.shadowBlur = 20;
            } else {
                ctx.fillStyle = "#fff";
                ctx.shadowColor = "cyan";
                ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        function drawBalls() { balls.forEach(drawBall); }
        function drawLasers() { lasers.forEach(l => { ctx.fillStyle = '#ff4d6d'; ctx.fillRect(l.x, l.y, LASER_WIDTH, LASER_HEIGHT); }); }
        
        function drawItems() {
            items.forEach(item => {
                const img = itemImages[item.type];
                let size = itemSizes[item.type] || itemSizes.life; // デフォルトサイズ
                if (img && img.complete) {
                    ctx.drawImage(img, item.x, item.y, size, size);
                } else {
                    // フォールバック描画
                    ctx.fillStyle = '#FF00FF'; 
                    ctx.fillRect(item.x, item.y, size, size);
                }
            });
        }
        
        function createExplosion(x, y, color, count = 15, size = 3) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * (size * 1.5),
                    vy: (Math.random() - 0.5) * (size * 1.5),
                    alpha: 1,
                    color: color,
                    size: Math.random() * size + 2,
                    lifespan: Math.random() * 30 + 30
                });
            }
        }

        function drawCracks(x, y, width, height, damage) {
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            for(let i=0; i < damage; i++) {
                ctx.beginPath();
                ctx.moveTo(x + Math.random() * width, y + Math.random() * height);
                ctx.lineTo(x + Math.random() * width, y + Math.random() * height);
                ctx.stroke();
            }
        }
        
        function drawInvaderShape(invader) {
            let color = invader.color;
            if (level >= 5 && invader.status > 0 && invader.status < invader.maxHealth) {
                color = "#9370DB";
            }
            ctx.fillStyle = color;

            const w = INVADER_WIDTH / 10; 
            const h = INVADER_HEIGHT / 8;
            const pattern = [ [0,0,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0],[1,1,1,0,1,1,0,1,1,1],[1,1,1,1,1,1,1,1,1,1],[0,0,1,0,0,0,0,1,0,0],[0,1,0,1,0,0,1,0,1,0],];
            for (let row = 0; row < pattern.length; row++) { for (let col = 0; col < pattern[row].length; col++) { if (pattern[row][col]) { ctx.fillRect(invader.x + col * w, invader.y + row * h, w, h); } } }
            
            const damage = invader.maxHealth - invader.status;
            if(damage > 0) {
                drawCracks(invader.x, invader.y, INVADER_WIDTH, INVADER_HEIGHT, damage);
            }
        }

        function drawInvaders() { 
            invaders.forEach(c => c.forEach(i => { 
                if (i.status > 0) { 
                    drawInvaderShape(i); 
                } 
            })); 
        }
        
        function drawUFO(ufoToDraw) {
            if (!ufoToDraw || !ufoToDraw.active) return;
            const w = ufoToDraw.width / 16;
            const h = ufoToDraw.height / 8;
            
            ctx.fillStyle = '#7CFC00';
            const dome = [
                [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            ];
            for(let r=0; r<dome.length; r++){
                 for(let c=0; c<dome[r].length; c++){
                    if(dome[r][c]){ ctx.fillRect(ufoToDraw.x + c * w, ufoToDraw.y + r*h, w, h); }
                }
            }

            ctx.fillStyle = '#C0C0C0';
            const body = [
                 [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ];
             for(let r=0; r<body.length; r++){
                 for(let c=0; c<body[r].length; c++){
                    if(body[r][c]){ ctx.fillRect(ufoToDraw.x + c * w, ufoToDraw.y + (r+2)*h, w, h); }
                }
            }

            const lightColor = (frameCount % 10 < 5) ? '#FFD700' : '#FF4500';
            ctx.fillStyle = lightColor;
            ctx.fillRect(ufoToDraw.x + 2*w, ufoToDraw.y + 4*h, w*2, h);
            ctx.fillRect(ufoToDraw.x + 12*w, ufoToDraw.y + 4*h, w*2, h);
        }

        function drawUfoLasers() {
            ufoLasers.forEach(laser => {
                ctx.save();
                const grad = ctx.createLinearGradient(laser.x, laser.y, laser.x, laser.y + 15);
                grad.addColorStop(0, 'rgba(255, 50, 50, 1)');
                grad.addColorStop(0.5, 'rgba(255, 100, 100, 0.5)');
                grad.addColorStop(1, 'rgba(255, 150, 150, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(laser.x - 2, laser.y, 4, 15);
                ctx.restore();
            });
        }
        
        function drawStars() {
            if (!stars) {
                stars = [];
                for (let i = 0; i < 150; i++) {
                    stars.push({
                        x: Math.random() * LOGICAL_WIDTH,
                        y: Math.random() * LOGICAL_HEIGHT,
                        radius: Math.random() * 1.5,
                        speed: Math.random() * 0.1 + 0.05
                    });
                }
            }
            
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > LOGICAL_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * LOGICAL_WIDTH;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawParticles() {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                ctx.beginPath();
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.alpha;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.03;
                p.lifespan--;
                if(p.lifespan <= 0) {
                    particles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1.0;
        }
        
        function drawComboText() {
            if (comboMultiplierDisplay && comboMultiplierDisplay.alpha > 0) {
                ctx.save();
                ctx.globalAlpha = comboMultiplierDisplay.alpha;
                ctx.font = "bold 20px 'Press Start 2P'";
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ff4500';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 4;
                ctx.fillText(comboMultiplierDisplay.text, comboMultiplierDisplay.x, comboMultiplierDisplay.y);
                ctx.restore();
            }
        }


        function triggerScreenEffect() {
            gameContainer.classList.add('shake');
            const flash = document.createElement('div');
            Object.assign(flash.style, { position: 'absolute', top: '0', left: '0', width: '100%', height: '100%', backgroundColor: 'rgba(255, 0, 0, 0.4)', opacity: '1', transition: 'opacity 0.3s ease-out', zIndex: '5' });
            gameContainer.appendChild(flash);
            setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.remove(), 300); }, 50);
            setTimeout(() => gameContainer.classList.remove('shake'), 500);
        }

        function resetGame() {
            score = 0; lives = 3; level = 1;
            isLevelTransitioning = false;
            lastTime = 0; 
            balls = [];
            particles = [];
            ufo = null;
            if(ufoSoundPlayer) {
                ufoSoundPlayer.stop().dispose();
                ufoSoundPlayer = null;
            }
            comboMultiplierDisplay = { text: '', alpha: 0, x: 0, y: 0 };
            startNextLevel();
            startBGM();
        }

        function startNextLevel() {
            levelEl.textContent = `LEVEL: ${level}`;
            wideShieldDropsThisStage = 0;
            heartDropsThisStage = 0;
            invincibleDropsThisStage = 0;
            multiBallDropsThisStage = 0;
            pierceDropsThisStage = 0;
            
            let levelSpeedMultiplier = Math.pow(1.03, Math.max(0, level - 1)); 
            invaderSpeed = LOGICAL_WIDTH * (0.06 + level * 0.0025) * levelSpeedMultiplier;
            player = { x: (LOGICAL_WIDTH - PADDLE_WIDTH) / 2, y: PADDLE_Y, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, speed: LOGICAL_WIDTH * 1.5, shieldWidth: PADDLE_WIDTH * 1.6, shieldEnhanced: false, isInvincible: false, paddleHit: { active: false, alpha: 0 } };
            
            const currentBallCount = balls.length > 0 ? balls.length : 1;
            balls = [];
            for (let i = 0; i < currentBallCount; i++) {
                 const angle = (Math.random() - 0.5) * Math.PI / 3;
                 balls.push({ x: player.x + PADDLE_WIDTH / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false, isGolden: false });
            }
            
            lasers = [];
            ufoLasers = [];
            items = []; 
            invadersMoveDirection = 1;
            invaderRowDirections = [];
            frameCount = 0;
            invaders = []; const invColors = ['#e71d36', '#ff9f1c', '#fca311', '#2ec4b6', '#a2d2ff'];
            for (let c = 0; c < INVADER_COLS; c++) {
                invaders[c] = [];
                for (let r = 0; r < INVADER_ROWS; r++) { 
                    const maxHealth = Math.floor(level / 5) + 1;
                    invaders[c][r] = { 
                        x: c * (INVADER_WIDTH + INVADER_PADDING) + INVADER_OFFSET_LEFT, 
                        y: r * (INVADER_HEIGHT + INVADER_PADDING) + INVADER_OFFSET_TOP, 
                        status: maxHealth,
                        maxHealth: maxHealth,
                        color: invColors[r % invColors.length], 
                        drop: null 
                    }; 
                }
            }
            
            for (let r = 0; r < INVADER_ROWS; r++) {
                if (level >= 5) {
                    invaderRowDirections[r] = Math.random() < 0.5 ? 1 : -1;
                } else {
                    invaderRowDirections[r] = 1;
                }
            }
            
            levelStartGracePeriod = true;
            setTimeout(() => { levelStartGracePeriod = false; }, 500);

            if ((!ufo || !ufo.active) && Math.random() < 1/7) {
                 setTimeout(spawnUFO, 10000);
            }
            
            const itemPool = [];
            for(let i = 0; i < 1; i++) itemPool.push('wideShield');
            for(let i = 0; i < 3; i++) itemPool.push('life');
            for(let i = 0; i < 1; i++) itemPool.push('invincible');
            for(let i = 0; i < 2; i++) itemPool.push('multiBall');
            for(let i = 0; i < 1; i++) itemPool.push('pierce');
            
            const allInvaders = invaders.flat();
            for (let i = allInvaders.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allInvaders[i], allInvaders[j]] = [allInvaders[j], allInvaders[i]];
            }
            
            for (let i = 0; i < itemPool.length && i < allInvaders.length; i++) {
                allInvaders[i].drop = itemPool[i];
            }
            
            updateUI();
        }
        
        function spawnUFO() {
            if (ufo && ufo.active) return;
            const direction = Math.random() < 0.5 ? 1 : -1;
            ufo = {
                x: direction === 1 ? -60 : LOGICAL_WIDTH,
                y: 50,
                width: 60,
                height: 30,
                speed: (LOGICAL_WIDTH + 60) / 8,
                direction: direction,
                active: true,
                shootInterval: null
            };

            if (ufoSoundPlayer) {
                ufoSoundPlayer.stop().dispose();
                ufoSoundPlayer = null;
            }
            ufoSoundPlayer = new Tone.Player(ufoBuffer).toDestination();
            ufoSoundPlayer.loop = true;
            ufoSoundPlayer.volume.value = -20;
            ufoSoundPlayer.start();

            ufo.shootInterval = setInterval(() => {
                if(ufo && ufo.active && gameState === 'PLAYING') {
                    ufoLasers.push({x: ufo.x + ufo.width/2, y: ufo.y + ufo.height, radius: 10, speed: laserSpeed});
                    sounds.ufoLaser();
                }
            }, 2000);

            ufo.disappearTimeout = setTimeout(() => {
                if(ufo && ufo.active) {
                    ufo.active = false;
                    clearInterval(ufo.shootInterval);
                    if(ufoSoundPlayer) {
                        ufoSoundPlayer.stop().dispose();
                        ufoSoundPlayer = null;
                    }
                }
            }, 8000);
        }
        
        function handleGameOver(isWin) {
            if (gameState === 'GAMEOVER') return;
            
            gameState = 'GAMEOVER'; 
            
            stopBGM();
            
            if (ufoSoundPlayer) {
                ufoSoundPlayer.stop().dispose();
                ufoSoundPlayer = null;
            }
            if (ufo && ufo.shootInterval) clearInterval(ufo.shootInterval);
            if(ufo && ufo.disappearTimeout) clearTimeout(ufo.disappearTimeout);
            
            pauseButton.style.display = 'none';
            
            [startScreen, pauseScreen, adScreen].forEach(el => el.classList.remove('active'));
            gameOverScreen.classList.add('active');

            document.getElementById('gameOverTitle').textContent = isWin ? "STAGE CLEAR!" : "GAME OVER";
            if (isWin) sounds.win(); else sounds.gameOver();
            
            if (score > highScore) {
                const newHighScore = score;
                highScore = newHighScore;
                document.getElementById('resultHighScore').textContent = newHighScore;
                saveHighScore(newHighScore).catch(e => {
                    console.error("Background score saving failed. Score was saved locally.", e);
                });
            } else {
                 document.getElementById('resultHighScore').textContent = highScore;
            }

            document.getElementById('resultLevel').textContent = level;
            document.getElementById('resultScore').textContent = score;
            
            const shareText = encodeURIComponent(`Block Raidersでレベル${level}に到達し、${score}点を獲得！あなたも挑戦してみる？ #ブロックレイダーズ #BlockRaiders`);
            const pageUrl = encodeURIComponent(GAME_URL);
            document.getElementById('shareX').href = `https://twitter.com/intent/tweet?text=${shareText}&url=${pageUrl}`;
            document.getElementById('shareFacebook').href = `https://www.facebook.com/sharer/sharer.php?u=${pageUrl}&quote=${shareText}`;
            document.getElementById('shareLine').href = `https://social-plugins.line.me/lineit/share?url=${pageUrl}&text=${shareText}`;
            
            document.getElementById('shareXAd').href = document.getElementById('shareX').href;
            document.getElementById('shareFacebookAd').href = document.getElementById('shareFacebook').href;
            document.getElementById('shareLineAd').href = document.getElementById('shareLine').href;
            
            const gameOverShareButtons = gameOverScreen.querySelector('.share-buttons');
            if(gameOverShareButtons) gameOverShareButtons.style.display = 'grid';
            
            gameOverCount++;
        }

        function updateUI() { scoreEl.textContent = `SCORE: ${score}`; livesEl.innerHTML = `LIVES: ${'❤'.repeat(lives)}`; levelEl.textContent = `LEVEL: ${level}`; }
        
        function update(deltaTime) {
            if (gameState !== 'PLAYING' || isLevelTransitioning) return;

            const moveDistance = player.speed * deltaTime;
            if (rightPressed && player.x < LOGICAL_WIDTH - PADDLE_WIDTH) player.x += moveDistance;
            if (leftPressed && player.x > 0) player.x -= moveDistance;

            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                ball.x += ball.dx * deltaTime; ball.y += ball.dy * deltaTime;
                if (ball.x < BALL_RADIUS) { ball.x = BALL_RADIUS; ball.dx = Math.abs(ball.dx); }
                if (ball.x > LOGICAL_WIDTH - BALL_RADIUS) { ball.x = LOGICAL_WIDTH - BALL_RADIUS; ball.dx = -Math.abs(ball.dx); }
                if (ball.y < BALL_RADIUS) {
                    ball.y = BALL_RADIUS;
                    ball.dy = Math.abs(ball.dy);
                }
                const barrierTop = player.y - player.height * 0.2;
                const barrierWidth = player.shieldWidth;
                const barrierX = player.x - (barrierWidth - player.width) / 2;
                if (ball.y + ball.radius > barrierTop && ball.x > barrierX && ball.x < barrierX + barrierWidth) {
                    ball.y = barrierTop - BALL_RADIUS;
                    comboCount = 0;
                    sounds.paddleHit();
                    player.paddleHit.active = true;
                    player.paddleHit.alpha = 1.0;
                    let collidePoint = (ball.x - (barrierX + barrierWidth / 2)) / (barrierWidth / 2);
                    let angle = collidePoint * (Math.PI / 3);
                    angle = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, angle));
                    ball.dx = ballSpeed * Math.sin(angle);
                    ball.dy = -Math.max(ballSpeed * Math.cos(angle), ballSpeed * 0.1); 
                }
                if (ball.y > LOGICAL_HEIGHT) { 
                    if (ball.isGolden) {
                        balls.forEach(b => b.isGolden = false);
                    }
                    balls.splice(i, 1); 
                }
            }
            if (balls.length === 0 && !isLevelTransitioning) {
                lives--;
                updateUI();
                if (lives <= 0) { 
                    handleGameOver(false);
                    return;
                } else {
                    sounds.playerHit();
                    const angle = (Math.random() - 0.5) * Math.PI / 3;
                    balls.push({ x: LOGICAL_WIDTH / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false, isGolden: false }); 
                }
            }

            let wallHit = false;
            let allDestroyed = true;

            if (level < 5) {
                let firstX = LOGICAL_WIDTH, lastX = 0;
                invaders.forEach(c => c.forEach(i => { if (i.status > 0) { allDestroyed = false; firstX = Math.min(firstX, i.x); lastX = Math.max(lastX, i.x); }}));
                if (!levelStartGracePeriod && (lastX + INVADER_WIDTH > LOGICAL_WIDTH || firstX < 0)) {
                    invadersMoveDirection *= -1;
                    wallHit = true;
                }
            } else {
                for (let r = 0; r < INVADER_ROWS; r++) {
                    let firstX_row = LOGICAL_WIDTH, lastX_row = 0, rowExists = false;
                     for (let c = 0; c < INVADER_COLS; c++) {
                        const invader = invaders[c][r];
                        if (invader.status > 0) {
                            rowExists = true;
                            firstX_row = Math.min(firstX_row, invader.x);
                            lastX_row = Math.max(lastX_row, invader.x);
                        }
                    }
                    if (!levelStartGracePeriod && rowExists && (lastX_row + INVADER_WIDTH > LOGICAL_WIDTH || firstX_row < 0)) {
                        invaderRowDirections[r] *= -1;
                        wallHit = true;
                    }
                }
            }
            
            if(wallHit) {
                const descentAmount = INVADER_HEIGHT / 2;
                invaders.forEach(c => c.forEach(i => i.y += descentAmount));
            }
            
            for (let c = 0; c < invaders.length; c++) {
                for (let r = 0; r < invaders[c].length; r++) {
                    const invader = invaders[c][r];
                    if (invader.status > 0) {
                        allDestroyed = false; 
                        let moveDirection = (level < 5) ? invadersMoveDirection : invaderRowDirections[r];
                        invader.x += invaderSpeed * moveDirection * deltaTime;
                        
                        if (invader.y + INVADER_HEIGHT > player.y) {
                            handleGameOver(false);
                            return;
                        }
                        
                        for (let i = balls.length - 1; i >= 0; i--) {
                            const ball = balls[i];
                            const invaderHitboxX = invader.x + INVADER_WIDTH * INVADER_HITBOX_INSET_X_RATIO;
                            const invaderHitboxY = invader.y + INVADER_HEIGHT * INVADER_HITBOX_INSET_Y_RATIO;
                            const invaderHitboxWidth = INVADER_WIDTH * (1 - 2 * INVADER_HITBOX_INSET_X_RATIO);
                            const invaderHitboxHeight = INVADER_HEIGHT * (1 - 2 * INVADER_HITBOX_INSET_Y_RATIO);

                            if (ball.x + ball.radius > invaderHitboxX && ball.x - ball.radius < invaderHitboxX + invaderHitboxWidth && ball.y + ball.radius > invaderHitboxY && ball.y - ball.radius < invaderHitboxY + invaderHitboxHeight) {
                                if (!ball.isPiercing && !ball.isGolden) {
                                    ball.dy *= -1;
                                    ball.dx += (Math.random() - 0.5) * 0.2; 
                                }
                                invader.status--;
                                
                                let scoreMultiplier = ball.isGolden ? 10 : 1;
                                if (!ball.isGolden) {
                                    comboCount++;
                                    if (comboCount >= 20) scoreMultiplier = 4;
                                    else if (comboCount >= 10) scoreMultiplier = 3;
                                    else if (comboCount >= 5) scoreMultiplier = 2;
                                }

                                if (scoreMultiplier > 1) {
                                    comboMultiplierDisplay = {
                                        text: `×${scoreMultiplier}`,
                                        x: invader.x + INVADER_WIDTH / 2,
                                        y: invader.y,
                                        alpha: 1.0
                                    };
                                    if (comboMultiplierDisplayTimeout) clearTimeout(comboMultiplierDisplayTimeout);
                                    comboMultiplierDisplayTimeout = setTimeout(() => {
                                        if(comboMultiplierDisplay) comboMultiplierDisplay.alpha = 0;
                                    }, 1000);
                                }

                                if(invader.status <= 0){
                                    sounds.destroy();
                                    createExplosion(invader.x + INVADER_WIDTH / 2, invader.y + INVADER_HEIGHT / 2, invader.color);
                                    score += (10 * invader.maxHealth) * scoreMultiplier;
                                    
                                    if (invader.drop) {
                                        items.push({x: invader.x + INVADER_WIDTH / 2, y: invader.y, type: invader.drop, size: itemSizes[invader.drop]});
                                        invader.drop = null;
                                    }
                                } else {
                                    sounds.hit();
                                    score += 1 * scoreMultiplier;
                                }
                                updateUI();
                                break; 
                            }
                        }
                    }
                }
            }

            if(allDestroyed && !isLevelTransitioning) {
                isLevelTransitioning = true;
                level++;
                sounds.win();
                setTimeout(() => { startNextLevel(); isLevelTransitioning = false; }, 1500);
                return;
            }

            frameCount++;
            if (ufo && ufo.active) {
                ufo.x += ufo.speed * ufo.direction * deltaTime;
                for (let i = balls.length - 1; i >= 0; i--) {
                    const ball = balls[i];
                    if (ball.x > ufo.x && ball.x < ufo.x + ufo.width && ball.y > ufo.y && ball.y < ufo.y + ufo.height) {
                        sounds.ufoDestroy();
                        createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, '#7CFC00', 50, 5);
                        ufo.active = false;
                        clearInterval(ufo.shootInterval);
                        if(ufoSoundPlayer) {
                            ufoSoundPlayer.stop().dispose();
                            ufoSoundPlayer = null;
                        }
                        ball.isGolden = true;
                        balls.forEach(b => { if(b !== ball) b.isGolden = false; });
                    }
                }
            }
            
            ufoLasers.forEach((l, i) => {
                l.y += l.speed * deltaTime;
                if (l.y > LOGICAL_HEIGHT) ufoLasers.splice(i,1);

                const dx = l.x - (player.x + player.width / 2);
                const dy = l.y - (player.y + player.height / 2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < l.radius + player.width / 2) {
                     ufoLasers.splice(i, 1);
                     if (!player.isInvincible) {
                        lives--; sounds.playerHit(); triggerScreenEffect(); if (lives <= 0) { handleGameOver(false); return; } updateUI();
                     }
                }
            });

            if (frameCount % (Math.max(30, 95 - level * 4)) === 0 && Math.random() < (0.15 + level * 0.025)) {
                let shooters = []; invaders.forEach(c => { for(let r=INVADER_ROWS-1; r>=0; r--) { if(c[r].status > 0) { shooters.push(c[r]); break; }}});
                if(shooters.length > 0) { const s = shooters[Math.floor(Math.random() * shooters.length)]; lasers.push({x: s.x + INVADER_WIDTH / 2 - LASER_WIDTH / 2, y: s.y + INVADER_HEIGHT }); sounds.laser(); }
            }
            lasers.forEach((l, i) => {
                l.y += laserSpeed * deltaTime; if (l.y > LOGICAL_HEIGHT) lasers.splice(i, 1);
                if (player.isInvincible) return;
                const playerHitboxX = player.x + PADDLE_WIDTH * PLAYER_HITBOX_INSET_X_RATIO;
                const playerHitboxY = player.y + PADDLE_HEIGHT * PLAYER_HITBOX_INSET_Y_RATIO;
                const playerHitboxWidth = PADDLE_WIDTH * (1 - 2 * PLAYER_HITBOX_INSET_X_RATIO);
                const playerHitboxHeight = PADDLE_HEIGHT * (1 - PLAYER_HITBOX_INSET_Y_RATIO);
                if (l.y + LASER_HEIGHT > playerHitboxY && l.y < playerHitboxY + playerHitboxHeight && l.x + LASER_WIDTH > playerHitboxX && l.x < playerHitboxX + playerHitboxWidth) {
                     lasers.splice(i, 1); lives--; sounds.playerHit(); triggerScreenEffect(); if (lives <= 0) { handleGameOver(false); return; } updateUI();
                }
            });
            items.forEach((item, i) => {
                item.y += itemSpeed * deltaTime; if (item.y > LOGICAL_HEIGHT) items.splice(i, 1);
                const itemHitboxX = item.x - item.size / 2;
                const itemHitboxY = item.y - item.size / 2;
                if(itemHitboxY + item.size > player.y && itemHitboxY < player.y + PADDLE_HEIGHT && itemHitboxX + item.size > player.x && itemHitboxX < player.x + PADDLE_WIDTH) {
                     if(item.type === 'life' && lives < 5) { lives++; sounds.getLife(); }
                     else if (item.type === 'multiBall') {
                         sounds.getMultiBall();
                         if (balls.length < 5) {
                            const angle = (Math.random() - 0.5) * Math.PI / 3;
                            balls.push({ x: player.x + player.width / 2, y: player.y - 20, radius: BALL_RADIUS, dx: ballSpeed * Math.sin(angle), dy: -ballSpeed * Math.cos(angle), isPiercing: false, isGolden: false });
                         }
                     } else if (item.type === 'pierce') {
                         sounds.getPierce();
                         balls.forEach(b => b.isPiercing = true);
                         if (pierceTimeoutId) clearTimeout(pierceTimeoutId);
                         pierceTimeoutId = setTimeout(() => { balls.forEach(b => b.isPiercing = false); }, PIERCE_DURATION);
                     } else if(item.type === 'wideShield') {
                         sounds.getShield();
                         player.shieldEnhanced = true;
                         player.shieldWidth = PADDLE_WIDTH * 2.2;
                         if(shieldTimeoutId) clearTimeout(shieldTimeoutId);
                         shieldTimeoutId = setTimeout(() => { player.shieldWidth = PADDLE_WIDTH * 1.6; player.shieldEnhanced = false; }, SHIELD_EXPAND_DURATION);
                     } else if (item.type === 'invincible') {
                         sounds.getInvincible();
                         player.isInvincible = true;
                         if(invincibleTimeoutId) clearTimeout(invincibleTimeoutId);
                         invincibleTimeoutId = setTimeout(() => { player.isInvincible = false; }, INVINCIBLE_DURATION);
                     }
                     items.splice(i, 1);
                     updateUI();
                }
            });
            
            if (player.paddleHit.active) {
                player.paddleHit.alpha -= 5 * deltaTime;
                if (player.paddleHit.alpha <= 0) {
                    player.paddleHit.active = false;
                }
            }

            if (comboMultiplierDisplay && comboMultiplierDisplay.alpha > 0) {
                 comboMultiplierDisplay.alpha -= 0.02;
            }
        }
        
        function draw() {
            if(!ctx) return;
            ctx.clearRect(0,0,LOGICAL_WIDTH, LOGICAL_HEIGHT);
            
            drawStars();

            if (gameState === 'PLAYING' || gameState === 'PAUSED') {
                drawInvaders();
                drawLasers();
                drawUfoLasers();
                drawItems();
                drawPlayer();
                drawUFO(ufo);
                drawBalls();
                drawParticles();
                drawComboText();
            }
        }
        
        let lastTime = 0;
        function mainLoop(timestamp) {
            if (gameState === 'GAMEOVER') {
                if (animationLoopId) {
                    cancelAnimationFrame(animationLoopId);
                    animationLoopId = null;
                }
                return;
            }
            
            animationLoopId = requestAnimationFrame(mainLoop);

            try {
                switch (gameState) {
                    case 'START':
                        ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
                        frameCount++; 
                        drawStars();
                        break;
                    case 'PLAYING':
                        if (!lastTime) lastTime = timestamp;
                        let deltaTime = (timestamp - lastTime) / 1000.0;
                        if (deltaTime > 0.1) deltaTime = 0.1;
                        
                        update(deltaTime);
                        draw();
                        lastTime = timestamp;
                        break;
                    case 'PAUSED':
                        draw();
                        lastTime = timestamp; 
                        break;
                }
            } catch (e) {
                console.error("Critical error in mainLoop, forcing game over:", e);
                handleGameOver(false);
            }
        }

        function togglePause() {
            if (gameState !== 'PLAYING' && gameState !== 'PAUSED') return;
            
            sounds.buttonClick();
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pauseScreen.classList.remove('active');
                pauseButton.innerHTML = '||';
                startBGM();
                if (ufoSoundPlayer && ufoSoundPlayer.state === 'paused') ufoSoundPlayer.start();
                lastTime = performance.now();
            } else {
                gameState = 'PAUSED';
                pauseScreen.classList.add('active');
                pauseButton.innerHTML = '▶';
                stopBGM();
                if (ufoSoundPlayer) ufoSoundPlayer.stop();
            }
        }
        
        pauseButton.addEventListener('click', togglePause);

        document.addEventListener('keydown', e => { 
            if (gameState !== 'PLAYING') return;
            if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true; else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true; 
        });
        document.addEventListener('keyup', e => { 
            if (gameState !== 'PLAYING') return;
            if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false; else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false; 
        });
        
        document.addEventListener('mousemove', e => {
            if(gameState !== 'PLAYING' || !player) return;
            const rect = canvas.getBoundingClientRect();
            const targetX = (e.clientX - rect.left) / rect.width * LOGICAL_WIDTH - (player.width / 2);
            player.x = Math.max(0, Math.min(targetX, LOGICAL_WIDTH - player.width));
        });

        canvas.addEventListener('touchstart', e => { 
            if (gameState !== 'PLAYING') return;
            e.preventDefault(); touchStartX = e.touches[0].clientX; 
        }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            if(gameState !== 'PLAYING' || !player) return;
            e.preventDefault();
            if(touchStartX === null ) return;
            const rect = canvas.getBoundingClientRect();
            const currentX = e.touches[0].clientX;
            const diffX = (currentX - touchStartX) * (LOGICAL_WIDTH / rect.width);
            player.x += diffX;
            player.x = Math.max(0, Math.min(player.x, LOGICAL_WIDTH - PADDLE_WIDTH));
            touchStartX = currentX;
        }, { passive: false });
        canvas.addEventListener('touchend', e => { 
            if (gameState !== 'PLAYING') return;
            e.preventDefault(); touchStartX = null; 
        });
        
        muteButton.addEventListener('click', () => {
            sounds.buttonClick();
            Tone.Master.mute = !Tone.Master.mute;
            muteButton.textContent = `SOUND: ${Tone.Master.mute ? 'OFF' : 'ON'}`;
            soundCheckbox.checked = !Tone.Master.mute;
        });
        
        soundCheckbox.addEventListener('change', () => {
            Tone.Master.mute = !soundCheckbox.checked;
            muteButton.textContent = `SOUND: ${Tone.Master.mute ? 'OFF' : 'ON'}`;
        });

        startButton.addEventListener('click', async () => { 
            if (gameState !== 'START') return;
            
            if (!audioInitialized) {
                try {
                    await Tone.start();
                    audioInitialized = true;
                    console.log("AudioContext started!");
                } catch(e) {
                    console.error("[ERROR] Could not start AudioContext on click:", e);
                }
            }
             sounds.buttonClick();
            
            gameState = 'PLAYING';
            startScreen.classList.remove('active');
            pauseButton.style.display = 'block';
            resetGame();
            lastTime = performance.now();
            if(!animationLoopId) mainLoop();
        });
        
        restartButton.addEventListener('click', () => {
            sounds.buttonClick();
            gameOverScreen.classList.remove('active');
            
            if (hasSharedEver) {
                gameState = 'PLAYING';
                pauseButton.style.display = 'block';
                resetGame();
                lastTime = performance.now();
                mainLoop();
            } else {
                playAdSimulation();
            }
        });

        function handleShareClick(e) { 
            hasSharedEver = true; 
            localStorage.setItem('blockRaidersShared', 'true');
            bottomBannerAd.style.display = 'none';
            document.body.classList.remove('with-banner');
            resizeCanvas(); 
            clearInterval(bannerInterval);
        }

        document.querySelectorAll('.share-buttons a').forEach(button => button.addEventListener('click', handleShareClick));
        
        function playAdSimulation() {
            adScreen.classList.add('active');
            const ad1 = `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+5YZ75" rel="nofollow" target="_blank"><img border="0" width="300" height="250" alt="" src="https://www23.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001003000&mc=1"></a><img border="0" width="1" height="1" src="https://www12.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+5YZ75" alt="">`;
            const ad2 = `<a href="https://click.duga.jp/aff/48328-01" target="_blank"><img src="https://ad.duga.jp/banner/aff/300-250.gif" alt="APEX アフィリエイト システム"></a>`;
            adContainer.innerHTML = (gameOverCount % 2 !== 0) ? ad1 : ad2;

            let timeLeft = 7;
            adTimerEl.textContent = `リトライまで ${timeLeft} 秒`;
            adRestartButton.style.display = "none";

            adTimerInterval = setInterval(() => {
                timeLeft--;
                adTimerEl.textContent = `リトライまで ${timeLeft} 秒`;
                if (timeLeft <= 0) {
                    clearInterval(adTimerInterval);
                    adTimerEl.textContent = "";
                    adRestartButton.style.display = "block";
                }
            }, 1000);
        }

        adRestartButton.addEventListener('click', () => {
            adScreen.classList.remove('active');
            gameState = 'PLAYING';
            pauseButton.style.display = 'block';
            resetGame();
            lastTime = performance.now();
            mainLoop();
        });
        
        function resizeCanvas() {
            const gameWrapper = document.getElementById('game-wrapper');
            const uiContainer = document.getElementById('uiContainer');
            if(!gameWrapper || !gameContainer) return;
            const { width, height } = gameWrapper.getBoundingClientRect();
            
            const wrapperStyle = window.getComputedStyle(gameWrapper);
            const wrapperPaddingLeft = parseFloat(wrapperStyle.paddingLeft);
            const wrapperPaddingRight = parseFloat(wrapperStyle.paddingRight);
            const contentWidth = width - wrapperPaddingLeft - wrapperPaddingRight;
            uiContainer.style.width = `${contentWidth}px`;
            
            const aspectRatio = LOGICAL_WIDTH / LOGICAL_HEIGHT;
            let newWidth = contentWidth;
            let newHeight = newWidth / aspectRatio;

            const gameContainerHeight = gameWrapper.clientHeight - uiContainer.offsetHeight;

            if (newHeight > gameContainerHeight) {
                newHeight = gameContainerHeight;
                newWidth = newHeight * aspectRatio;
            }
            
            gameContainer.style.width = `${newWidth}px`;
            gameContainer.style.height = `${newHeight}px`;
            
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            const logoImage = document.getElementById('logo-image');
            if (logoImage) {
                logoImage.style.width = `${newWidth * 0.8}px`;
                logoImage.style.height = 'auto';
            }


            const dpr = window.devicePixelRatio || 1;
            canvas.width = LOGICAL_WIDTH;
            canvas.height = LOGICAL_HEIGHT;
            
            PADDLE_WIDTH = LOGICAL_WIDTH * PADDLE_WIDTH_RATIO;
            PADDLE_HEIGHT = LOGICAL_HEIGHT * PADDLE_HEIGHT_RATIO;
            BALL_RADIUS = LOGICAL_WIDTH * BALL_RADIUS_RATIO;
            LASER_WIDTH = LOGICAL_WIDTH * LASER_WIDTH_RATIO;
            LASER_HEIGHT = LOGICAL_HEIGHT * LASER_HEIGHT_RATIO;
            
            const baseItemSize = LOGICAL_WIDTH * BASE_ITEM_SIZE_RATIO;
            itemSizes = {
                life: baseItemSize,
                pierce: baseItemSize * 1.2,
                multiBall: baseItemSize * 1.2,
                wideShield: baseItemSize * 1.3,
                invincible: baseItemSize / 1.2
            };


            PADDLE_Y = LOGICAL_HEIGHT - PADDLE_HEIGHT * 2.5;

            INVADER_WIDTH = LOGICAL_WIDTH * 0.075;
            INVADER_HEIGHT = LOGICAL_HEIGHT * 0.04;
            INVADER_PADDING = LOGICAL_WIDTH * 0.025;
            INVADER_OFFSET_TOP = LOGICAL_HEIGHT * 0.083;
            INVADER_OFFSET_LEFT = (LOGICAL_WIDTH - (INVADER_COLS * (INVADER_WIDTH + INVADER_PADDING))) / 2;
            
            ballSpeed = LOGICAL_HEIGHT * 0.75 * 1.1;
            laserSpeed = LOGICAL_HEIGHT * 0.5;
            itemSpeed = LOGICAL_HEIGHT * 0.2;
        }
        
        window.onresize = resizeCanvas;
        
        const bannerAds = [
            `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+5ZU29" rel="nofollow" target="_blank"><img border="0" width="320" height="50" alt="" src="https://www20.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001007000&mc=1"></a><img border="0" width="1" height="1" src="https://www10.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+5ZU29" alt="">`,
            `<a href="https://px.a8.net/svt/ejp?a8mat=457IC4+7RTRVE+5PZK+601S1" rel="nofollow" target="_blank"><img border="0" width="320" height="50" alt="" src="https://www21.a8.net/svt/bgt?aid=250613140470&wid=002&eno=01&mid=s00000026696001008000&mc=1"></a><img border="0" width="1" height="1" src="https://www17.a8.net/0.gif?a8mat=457IC4+7RTRVE+5PZK+601S1" alt="">`
        ];
        let currentAdIndex = 0;
        let bannerInterval;

        function showBannerAd() {
            if(hasSharedEver) return;
            bannerContent.innerHTML = bannerAds[currentAdIndex];
            bottomBannerAd.style.display = 'flex';
            document.body.classList.add('with-banner');
            resizeCanvas(); 
            currentAdIndex = (currentAdIndex + 1) % bannerAds.length;
        }
        
        function startBannerRotation() {
            if(hasSharedEver || bannerInterval) return;
            showBannerAd();
            bannerInterval = setInterval(showBannerAd, 10000);
        }

        if(closeBannerBtn) {
            closeBannerBtn.addEventListener('click', () => {
                bottomBannerAd.style.display = 'none';
                document.body.classList.remove('with-banner');
                resizeCanvas(); 
                clearInterval(bannerInterval);
            });
        }

        async function initGame() {
            await initializeFirebase(); 
            
            if(canvas.getContext) {
                ctx = canvas.getContext('2d');
            }
            if(!ctx) {
                console.error("2D context not supported");
                return;
            }
            resizeCanvas(); 
            
            console.log("[DEBUG] Initializing BGM & SFX loading...");
            startButton.disabled = true;
            try {
                 const imagePromises = Object.entries(ICON_URLS).map(([key, url]) => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; 
                        img.onload = () => {
                            itemImages[key] = img;
                            resolve();
                        };
                        img.onerror = () => {
                             console.error(`Failed to load item image: ${key}`);
                             resolve(); 
                        };
                        img.src = url;
                    });
                });

                 await Promise.all([
                    ...imagePromises,
                    bgmPlayer.load(BGM_URL),
                    new Promise(res => { buttonClickBuffer = new Tone.Buffer(BUTTON_CLICK_URL, res); }),
                    new Promise(res => { hitBuffer = new Tone.Buffer(ENEMY_HIT_URL, res); }),
                    new Promise(res => { destroyBuffer = new Tone.Buffer(ENEMY_DEATH_URL, res); }),
                    new Promise(res => { playerHitBuffer = new Tone.Buffer(PLAYER_HIT_URL, res); }),
                    new Promise(res => { paddleHitBuffer = new Tone.Buffer(PADDLE_HIT_URL, res); }),
                    new Promise(res => { healBuffer = new Tone.Buffer(HEAL_URL, res); }),
                    new Promise(res => { itemBuffer = new Tone.Buffer(POWERUP_URL, res); }),
                    new Promise(res => { ufoBuffer = new Tone.Buffer(UFO_URL, res); }),
                    new Promise(res => { ufoLaserBuffer = new Tone.Buffer(UFO_LASER_URL, res); }),
                    new Promise(res => { ufoDestroyBuffer = new Tone.Buffer(UFO_DEATH_URL, res); })
                ]);
                console.log("[DEBUG] All audio buffers loaded successfully.");
                startButton.disabled = false;
                startButton.textContent = "START GAME";
                if (!hasSharedEver) {
                    startBannerRotation();
                }
            } catch(e) {
                console.error("[ERROR] Failed to load sounds.", e);
                startButton.textContent = "START (NO SOUND)";
                startButton.disabled = false;
            }
            
            mainLoop();
        }
        initGame();
    });

    </script>
</body>
</html>
